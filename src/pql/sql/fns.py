"""DuckDB SQL function wrappers with type hints.

This file is AUTO-GENERATED by scripts/generate_fns.py
Do not edit manually - regenerate with:
    uv run -m scripts.generator

Functions are extracted from DuckDB's duckdb_functions() introspection.
"""

from __future__ import annotations

from datetime import date, datetime, time, timedelta
from decimal import Decimal
from typing import Self

from duckdb import Expression

from ._core import ExprHandler, NameSpaceHandler, func


class Fns(ExprHandler[Expression]):
    """Mixin providing auto-generated DuckDB functions as methods."""

    def abs(self) -> Self:
        """Absolute value.

        Returns:
            Self
        """
        return self.__class__(func("abs", self._expr))

    def acos(self) -> Self:
        """Computes the arccosine of x.

        Returns:
            Self
        """
        return self.__class__(func("acos", self._expr))

    def acosh(self) -> Self:
        """Computes the inverse hyperbolic cos of x.

        Returns:
            Self
        """
        return self.__class__(func("acosh", self._expr))

    def add(
        self,
        col1: Self | Decimal | date | datetime | float | time | timedelta | None = None,
        *args: Self,
    ) -> Self:
        """SQL add function.

        Args:
            col1 (Self | Decimal | date | datetime | float | int | time | timedelta | None): `BIGINT | BIGNUM | DATE | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | INTERVAL | SMALLINT | TIME | TIME WITH TIME ZONE | TIMESTAMP | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression
            *args (Self): `ANY[]` expression

        Returns:
            Self
        """
        return self.__class__(func("add", self._expr, col1, *args))

    def age(self, timestamp_3: Self | datetime | None = None) -> Self:
        """Subtract arguments, resulting in the time difference between the two timestamps.

        Args:
            timestamp_3 (Self | datetime | None): `TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

        Returns:
            Self
        """
        return self.__class__(func("age", self._expr, timestamp_3))

    def any_value(self) -> Self:
        """Returns the first non-NULL value from arg.

        This function is affected by ordering.

        Returns:
            Self
        """
        return self.__class__(func("any_value", self._expr))

    def approx_count_distinct(self) -> Self:
        """Computes the approximate count of distinct elements using HyperLogLog.

        Returns:
            Self
        """
        return self.__class__(func("approx_count_distinct", self._expr))

    def approx_quantile(self, pos: Self | float | list[float]) -> Self:
        """Computes the approximate quantile using T-Digest.

        Args:
            pos (Self | float | list[float]): `FLOAT | FLOAT[]` expression

        Returns:
            Self
        """
        return self.__class__(func("approx_quantile", self._expr, pos))

    def approx_top_k(self, k: Self | int) -> Self:
        """Finds the k approximately most occurring values in the data set.

        Args:
            k (Self | int): `BIGINT` expression

        Returns:
            Self
        """
        return self.__class__(func("approx_top_k", self._expr, k))

    def arbitrary(self) -> Self:
        """Returns the first value (NULL or non-NULL) from arg.

        This function is affected by ordering.

        See Also:
            first

        Returns:
            Self
        """
        return self.__class__(func("arbitrary", self._expr))

    def arg_max(
        self,
        val: Self | bytes | bytearray | memoryview | date | datetime | float | str,
        col2: Self | int | None = None,
    ) -> Self:
        """Finds the row with the maximum val.

        Calculates the non-NULL arg expression at that row.

        See Also:
            argmax, max_by

        Args:
            val (Self | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DOUBLE | HUGEINT | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression
            col2 (Self | int | None): `BIGINT` expression

        Returns:
            Self
        """
        return self.__class__(func("arg_max", self._expr, val, col2))

    def arg_max_null(
        self, val: Self | bytes | bytearray | memoryview | date | datetime | float | str
    ) -> Self:
        """Finds the row with the maximum val.

        Calculates the arg expression at that row.

        Args:
            val (Self | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DOUBLE | HUGEINT | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression

        Returns:
            Self
        """
        return self.__class__(func("arg_max_null", self._expr, val))

    def arg_min(
        self,
        val: Self | bytes | bytearray | memoryview | date | datetime | float | str,
        col2: Self | int | None = None,
    ) -> Self:
        """Finds the row with the minimum val.

        Calculates the non-NULL arg expression at that row.

        See Also:
            argmin, min_by

        Args:
            val (Self | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DOUBLE | HUGEINT | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression
            col2 (Self | int | None): `BIGINT` expression

        Returns:
            Self
        """
        return self.__class__(func("arg_min", self._expr, val, col2))

    def arg_min_null(
        self, val: Self | bytes | bytearray | memoryview | date | datetime | float | str
    ) -> Self:
        """Finds the row with the minimum val.

        Calculates the arg expression at that row.

        Args:
            val (Self | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DOUBLE | HUGEINT | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression

        Returns:
            Self
        """
        return self.__class__(func("arg_min_null", self._expr, val))

    def argmax(
        self,
        val: Self | bytes | bytearray | memoryview | date | datetime | float | str,
        col2: Self | int | None = None,
    ) -> Self:
        """Finds the row with the maximum val.

        Calculates the non-NULL arg expression at that row.

        See Also:
            arg_max, max_by

        Args:
            val (Self | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DOUBLE | HUGEINT | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression
            col2 (Self | int | None): `BIGINT` expression

        Returns:
            Self
        """
        return self.__class__(func("argmax", self._expr, val, col2))

    def argmin(
        self,
        val: Self | bytes | bytearray | memoryview | date | datetime | float | str,
        col2: Self | int | None = None,
    ) -> Self:
        """Finds the row with the minimum val.

        Calculates the non-NULL arg expression at that row.

        See Also:
            arg_min, min_by

        Args:
            val (Self | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DOUBLE | HUGEINT | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression
            col2 (Self | int | None): `BIGINT` expression

        Returns:
            Self
        """
        return self.__class__(func("argmin", self._expr, val, col2))

    def asin(self) -> Self:
        """Computes the arcsine of x.

        Returns:
            Self
        """
        return self.__class__(func("asin", self._expr))

    def asinh(self) -> Self:
        """Computes the inverse hyperbolic sin of x.

        Returns:
            Self
        """
        return self.__class__(func("asinh", self._expr))

    def atan(self) -> Self:
        """Computes the arctangent of x.

        Returns:
            Self
        """
        return self.__class__(func("atan", self._expr))

    def atan2(self, x: Self | float) -> Self:
        """Computes the arctangent (y, x).

        Args:
            x (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("atan2", self._expr, x))

    def atanh(self) -> Self:
        """Computes the inverse hyperbolic tan of x.

        Returns:
            Self
        """
        return self.__class__(func("atanh", self._expr))

    def avg(self) -> Self:
        """Calculates the average value for all tuples in x.

        See Also:
            mean

        Returns:
            Self
        """
        return self.__class__(func("avg", self._expr))

    def bin(self) -> Self:
        """Converts the `value` to binary representation.

        See Also:
            to_binary

        Returns:
            Self
        """
        return self.__class__(func("bin", self._expr))

    def bit_and(self) -> Self:
        """Returns the bitwise AND of all bits in a given expression.

        Returns:
            Self
        """
        return self.__class__(func("bit_and", self._expr))

    def bit_count(self) -> Self:
        """Returns the number of bits that are set.

        Returns:
            Self
        """
        return self.__class__(func("bit_count", self._expr))

    def bit_length(self) -> Self:
        """Returns the bit-length of the `bit` argument.

        Returns:
            Self
        """
        return self.__class__(func("bit_length", self._expr))

    def bit_or(self) -> Self:
        """Returns the bitwise OR of all bits in a given expression.

        Returns:
            Self
        """
        return self.__class__(func("bit_or", self._expr))

    def bit_position(self, bitstring: Self | bytes | bytearray | memoryview) -> Self:
        """Returns first starting index of the specified substring within bits, or zero if it is not present.

        The first (leftmost) bit is indexed 1.

        Args:
            bitstring (Self | bytes | bytearray | memoryview): `BIT` expression

        Returns:
            Self
        """
        return self.__class__(func("bit_position", self._expr, bitstring))

    def bit_xor(self) -> Self:
        """Returns the bitwise XOR of all bits in a given expression.

        Returns:
            Self
        """
        return self.__class__(func("bit_xor", self._expr))

    def bitstring(self, length: Self | int) -> Self:
        """Pads the bitstring until the specified length.

        Args:
            length (Self | int): `INTEGER` expression

        Returns:
            Self
        """
        return self.__class__(func("bitstring", self._expr, length))

    def bitstring_agg(
        self, col1: Self | int | None = None, col2: Self | int | None = None
    ) -> Self:
        """Returns a bitstring with bits set for each distinct value.

        Args:
            col1 (Self | int | None): `BIGINT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression
            col2 (Self | int | None): `BIGINT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

        Returns:
            Self
        """
        return self.__class__(func("bitstring_agg", self._expr, col1, col2))

    def bool_and(self) -> Self:
        """Returns TRUE if every input value is TRUE, otherwise FALSE.

        Returns:
            Self
        """
        return self.__class__(func("bool_and", self._expr))

    def bool_or(self) -> Self:
        """Returns TRUE if any input value is TRUE, otherwise FALSE.

        Returns:
            Self
        """
        return self.__class__(func("bool_or", self._expr))

    def can_cast_implicitly(self, target_type: Self) -> Self:
        """Whether or not we can implicitly cast from the source type to the other type.

        Args:
            target_type (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("can_cast_implicitly", self._expr, target_type))

    def cardinality(self, *args: Self) -> Self:
        """Returns the size of the map (or the number of entries in the map).

        Args:
            *args (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("cardinality", self._expr, *args))

    def cast_to_type(self, type_arg: Self) -> Self:
        """Casts the first argument to the type of the second argument.

        Args:
            type_arg (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("cast_to_type", self._expr, type_arg))

    def cbrt(self) -> Self:
        """Returns the cube root of x.

        Returns:
            Self
        """
        return self.__class__(func("cbrt", self._expr))

    def ceil(self) -> Self:
        """Rounds the number up.

        See Also:
            ceiling

        Returns:
            Self
        """
        return self.__class__(func("ceil", self._expr))

    def ceiling(self) -> Self:
        """Rounds the number up.

        See Also:
            ceil

        Returns:
            Self
        """
        return self.__class__(func("ceiling", self._expr))

    def century(self) -> Self:
        """Extract the century component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("century", self._expr))

    def char_length(self) -> Self:
        """Returns the bit-length of the `bit` argument.

        See Also:
            character_length, len, length

        Returns:
            Self
        """
        return self.__class__(func("char_length", self._expr))

    def character_length(self) -> Self:
        """Returns the bit-length of the `bit` argument.

        See Also:
            char_length, len, length

        Returns:
            Self
        """
        return self.__class__(func("character_length", self._expr))

    def col_description(self, column_number: Self) -> Self:
        """SQL col_description function.

        Args:
            column_number (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("col_description", self._expr, column_number))

    def combine(self, col1: Self) -> Self:
        """SQL combine function.

        Args:
            col1 (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("combine", self._expr, col1))

    def constant_or_null(self, arg2: Self, *args: Self) -> Self:
        """If arg2 is NULL, return NULL.

        Otherwise, return arg1.

        Args:
            arg2 (Self): `ANY` expression
            *args (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("constant_or_null", self._expr, arg2, *args))

    def contains(self, col1: Self) -> Self:
        """SQL contains function.

        Args:
            col1 (Self): `ANY | K | T` expression

        Returns:
            Self
        """
        return self.__class__(func("contains", self._expr, col1))

    def corr(self, x: Self | float) -> Self:
        """Returns the correlation coefficient for non-NULL pairs in a group.

        Args:
            x (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("corr", self._expr, x))

    def cos(self) -> Self:
        """Computes the cos of x.

        Returns:
            Self
        """
        return self.__class__(func("cos", self._expr))

    def cosh(self) -> Self:
        """Computes the hyperbolic cos of x.

        Returns:
            Self
        """
        return self.__class__(func("cosh", self._expr))

    def cot(self) -> Self:
        """Computes the cotangent of x.

        Returns:
            Self
        """
        return self.__class__(func("cot", self._expr))

    def count(self) -> Self:
        """Returns the number of non-NULL values in arg.

        Returns:
            Self
        """
        return self.__class__(func("count", self._expr))

    def count_if(self) -> Self:
        """Counts the total number of TRUE values for a boolean column.

        See Also:
            countif

        Returns:
            Self
        """
        return self.__class__(func("count_if", self._expr))

    def countif(self) -> Self:
        """Counts the total number of TRUE values for a boolean column.

        See Also:
            count_if

        Returns:
            Self
        """
        return self.__class__(func("countif", self._expr))

    def covar_pop(self, x: Self | float) -> Self:
        """Returns the population covariance of input values.

        Args:
            x (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("covar_pop", self._expr, x))

    def covar_samp(self, x: Self | float) -> Self:
        """Returns the sample covariance for non-NULL pairs in a group.

        Args:
            x (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("covar_samp", self._expr, x))

    def create_sort_key(self, *args: Self) -> Self:
        """Constructs a binary-comparable sort key based on a set of input parameters and sort qualifiers.

        Args:
            *args (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("create_sort_key", self._expr, *args))

    def currval(self) -> Self:
        """Return the current value of the sequence.

        Note that nextval must be called at least once prior to calling currval.

        Returns:
            Self
        """
        return self.__class__(func("currval", self._expr))

    def decade(self) -> Self:
        """Extract the decade component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("decade", self._expr))

    def decode(self) -> Self:
        """Converts `blob` to `VARCHAR`.

        Fails if `blob` is not valid UTF-8.

        Returns:
            Self
        """
        return self.__class__(func("decode", self._expr))

    def degrees(self) -> Self:
        """Converts radians to degrees.

        Returns:
            Self
        """
        return self.__class__(func("degrees", self._expr))

    def divide(self, col1: Self | float) -> Self:
        """SQL divide function.

        Args:
            col1 (Self | float | int): `BIGINT | DOUBLE | FLOAT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

        Returns:
            Self
        """
        return self.__class__(func("divide", self._expr, col1))

    def element_at(self, key: Self) -> Self:
        """Returns a list containing the value for a given key or an empty list if the key is not contained in the map.

        The type of the key provided in the second parameter must match the type of the map's keys else an error is returned.

        See Also:
            map_extract

        Args:
            key (Self): `K` expression

        Returns:
            Self
        """
        return self.__class__(func("element_at", self._expr, key))

    def encode(self) -> Self:
        """Converts the `string` to `BLOB`.

        Converts UTF-8 characters into literal encoding.

        Returns:
            Self
        """
        return self.__class__(func("encode", self._expr))

    def entropy(self) -> Self:
        """Returns the log-2 entropy of count input-values.

        Returns:
            Self
        """
        return self.__class__(func("entropy", self._expr))

    def enum_code(self) -> Self:
        """Returns the numeric value backing the given enum value.

        Returns:
            Self
        """
        return self.__class__(func("enum_code", self._expr))

    def enum_first(self) -> Self:
        """Returns the first value of the input enum type.

        Returns:
            Self
        """
        return self.__class__(func("enum_first", self._expr))

    def enum_last(self) -> Self:
        """Returns the last value of the input enum type.

        Returns:
            Self
        """
        return self.__class__(func("enum_last", self._expr))

    def enum_range(self) -> Self:
        """Returns all values of the input enum type as an array.

        Returns:
            Self
        """
        return self.__class__(func("enum_range", self._expr))

    def enum_range_boundary(self, end: Self) -> Self:
        """Returns the range between the two given enum values as an array.

        The values must be of the same enum type.

        When the first parameter is NULL, the result starts with the first value of the enum type.

        When the second parameter is NULL, the result ends with the last value of the enum type.

        Args:
            end (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("enum_range_boundary", self._expr, end))

    def epoch(self) -> Self:
        """Extract the epoch component from a temporal type.

        Returns:
            Self
        """
        return self.__class__(func("epoch", self._expr))

    def epoch_ms(self) -> Self:
        """Extract the epoch component in milliseconds from a temporal type.

        Returns:
            Self
        """
        return self.__class__(func("epoch_ms", self._expr))

    def epoch_ns(self) -> Self:
        """Extract the epoch component in nanoseconds from a temporal type.

        Returns:
            Self
        """
        return self.__class__(func("epoch_ns", self._expr))

    def epoch_us(self) -> Self:
        """Extract the epoch component in microseconds from a temporal type.

        Returns:
            Self
        """
        return self.__class__(func("epoch_us", self._expr))

    def equi_width_bins(
        self,
        max_arg: Self | datetime | float,
        bin_count: Self | int,
        nice_rounding: Self | bool,
    ) -> Self:
        """Generates bin_count equi-width bins between the min and max.

        If enabled nice_rounding makes the numbers more readable/less jagged.

        Args:
            max_arg (Self | datetime | float | int): `ANY | BIGINT | DOUBLE | TIMESTAMP` expression
            bin_count (Self | int): `BIGINT` expression
            nice_rounding (Self | bool): `BOOLEAN` expression

        Returns:
            Self
        """
        return self.__class__(
            func("equi_width_bins", self._expr, max_arg, bin_count, nice_rounding)
        )

    def era(self) -> Self:
        """Extract the era component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("era", self._expr))

    def error(self) -> Self:
        """Throws the given error message.

        Returns:
            Self
        """
        return self.__class__(func("error", self._expr))

    def even(self) -> Self:
        """Rounds x to next even number by rounding away from zero.

        Returns:
            Self
        """
        return self.__class__(func("even", self._expr))

    def exp(self) -> Self:
        """Computes e to the power of x.

        Returns:
            Self
        """
        return self.__class__(func("exp", self._expr))

    def factorial(self) -> Self:
        """Factorial of x.

        Computes the product of the current integer and all integers below it.

        Returns:
            Self
        """
        return self.__class__(func("factorial", self._expr))

    def favg(self) -> Self:
        """Calculates the average using a more accurate floating point summation (Kahan Sum).

        Returns:
            Self
        """
        return self.__class__(func("favg", self._expr))

    def fdiv(self, y: Self) -> Self:
        """SQL fdiv function.

        Args:
            y (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("fdiv", self._expr, y))

    def finalize(self) -> Self:
        """SQL finalize function.

        Returns:
            Self
        """
        return self.__class__(func("finalize", self._expr))

    def first(self) -> Self:
        """Returns the first value (NULL or non-NULL) from arg.

        This function is affected by ordering.

        See Also:
            arbitrary

        Returns:
            Self
        """
        return self.__class__(func("first", self._expr))

    def floor(self) -> Self:
        """Rounds the number down.

        Returns:
            Self
        """
        return self.__class__(func("floor", self._expr))

    def fmod(self, y: Self) -> Self:
        """SQL fmod function.

        Args:
            y (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("fmod", self._expr, y))

    def format_pg_type(self, type_name: Self) -> Self:
        """SQL format_pg_type function.

        Args:
            type_name (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("format_pg_type", self._expr, type_name))

    def format_type(self, typemod: Self) -> Self:
        """SQL format_type function.

        Args:
            typemod (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("format_type", self._expr, typemod))

    def from_json(self, col1: Self | str) -> Self:
        """SQL from_json function.

        Args:
            col1 (Self | str): `VARCHAR` expression

        Returns:
            Self
        """
        return self.__class__(func("from_json", self._expr, col1))

    def from_json_strict(self, col1: Self | str) -> Self:
        """SQL from_json_strict function.

        Args:
            col1 (Self | str): `VARCHAR` expression

        Returns:
            Self
        """
        return self.__class__(func("from_json_strict", self._expr, col1))

    def fsum(self) -> Self:
        """Calculates the sum using a more accurate floating point summation (Kahan Sum).

        See Also:
            kahan_sum, sumkahan

        Returns:
            Self
        """
        return self.__class__(func("fsum", self._expr))

    def gamma(self) -> Self:
        """Interpolation of (x-1) factorial (so decimal inputs are allowed).

        Returns:
            Self
        """
        return self.__class__(func("gamma", self._expr))

    def gcd(self, y: Self | int) -> Self:
        """Computes the greatest common divisor of x and y.

        See Also:
            greatest_common_divisor

        Args:
            y (Self | int): `BIGINT | HUGEINT` expression

        Returns:
            Self
        """
        return self.__class__(func("gcd", self._expr, y))

    def generate_subscripts(self, dim: Self) -> Self:
        """SQL generate_subscripts function.

        Args:
            dim (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("generate_subscripts", self._expr, dim))

    def geomean(self) -> Self:
        """SQL geomean function.

        Returns:
            Self
        """
        return self.__class__(func("geomean", self._expr))

    def geometric_mean(self) -> Self:
        """SQL geometric_mean function.

        Returns:
            Self
        """
        return self.__class__(func("geometric_mean", self._expr))

    def get_bit(self, index: Self | int) -> Self:
        """Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0.

        Args:
            index (Self | int): `INTEGER` expression

        Returns:
            Self
        """
        return self.__class__(func("get_bit", self._expr, index))

    def get_block_size(self) -> Self:
        """SQL get_block_size function.

        Returns:
            Self
        """
        return self.__class__(func("get_block_size", self._expr))

    def getvariable(self) -> Self:
        """SQL getvariable function.

        Returns:
            Self
        """
        return self.__class__(func("getvariable", self._expr))

    def greatest_common_divisor(self, y: Self | int) -> Self:
        """Computes the greatest common divisor of x and y.

        See Also:
            gcd

        Args:
            y (Self | int): `BIGINT | HUGEINT` expression

        Returns:
            Self
        """
        return self.__class__(func("greatest_common_divisor", self._expr, y))

    def group_concat(self, arg: Self | str | None = None) -> Self:
        """Concatenates the column string values with an optional separator.

        See Also:
            listagg, string_agg

        Args:
            arg (Self | str | None): `VARCHAR` expression

        Returns:
            Self
        """
        return self.__class__(func("group_concat", self._expr, arg))

    def hex(self) -> Self:
        """Converts the `value` to `VARCHAR` using hexadecimal representation.

        See Also:
            to_hex

        Returns:
            Self
        """
        return self.__class__(func("hex", self._expr))

    def histogram(self, col1: Self | None = None) -> Self:
        """Returns a LIST of STRUCTs with the fields bucket and count.

        Args:
            col1 (Self | None): `ANY[]` expression

        Returns:
            Self
        """
        return self.__class__(func("histogram", self._expr, col1))

    def histogram_exact(self, bins: Self) -> Self:
        """Returns a LIST of STRUCTs with the fields bucket and count matching the buckets exactly.

        Args:
            bins (Self): `ANY[]` expression

        Returns:
            Self
        """
        return self.__class__(func("histogram_exact", self._expr, bins))

    def hour(self) -> Self:
        """Extract the hour component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("hour", self._expr))

    def in_search_path(self, schema_name: Self | str) -> Self:
        """Returns whether or not the database/schema are in the search path.

        Args:
            schema_name (Self | str): `VARCHAR` expression

        Returns:
            Self
        """
        return self.__class__(func("in_search_path", self._expr, schema_name))

    def is_histogram_other_bin(self) -> Self:
        """Whether or not the provided value is the histogram "other" bin (used for values not belonging to any provided bin).

        Returns:
            Self
        """
        return self.__class__(func("is_histogram_other_bin", self._expr))

    def isfinite(self) -> Self:
        """Returns true if the floating point value is finite, false otherwise.

        Returns:
            Self
        """
        return self.__class__(func("isfinite", self._expr))

    def isinf(self) -> Self:
        """Returns true if the floating point value is infinite, false otherwise.

        Returns:
            Self
        """
        return self.__class__(func("isinf", self._expr))

    def isnan(self) -> Self:
        """Returns true if the floating point value is not a number, false otherwise.

        Returns:
            Self
        """
        return self.__class__(func("isnan", self._expr))

    def isodow(self) -> Self:
        """Extract the isodow component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("isodow", self._expr))

    def isoyear(self) -> Self:
        """Extract the isoyear component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("isoyear", self._expr))

    def json(self) -> Self:
        """SQL json function.

        Returns:
            Self
        """
        return self.__class__(func("json", self._expr))

    def julian(self) -> Self:
        """Extract the Julian Day number from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("julian", self._expr))

    def kahan_sum(self) -> Self:
        """Calculates the sum using a more accurate floating point summation (Kahan Sum).

        See Also:
            fsum, sumkahan

        Returns:
            Self
        """
        return self.__class__(func("kahan_sum", self._expr))

    def kurtosis(self) -> Self:
        """Returns the excess kurtosis (Fisher's definition) of all input values, with a bias correction according to the sample size.

        Returns:
            Self
        """
        return self.__class__(func("kurtosis", self._expr))

    def kurtosis_pop(self) -> Self:
        """Returns the excess kurtosis (Fisher's definition) of all input values, without bias correction.

        Returns:
            Self
        """
        return self.__class__(func("kurtosis_pop", self._expr))

    def last(self) -> Self:
        """Returns the last value of a column.

        This function is affected by ordering.

        Returns:
            Self
        """
        return self.__class__(func("last", self._expr))

    def last_day(self) -> Self:
        """Returns the last day of the month.

        Returns:
            Self
        """
        return self.__class__(func("last_day", self._expr))

    def lcm(self, y: Self | int) -> Self:
        """Computes the least common multiple of x and y.

        See Also:
            least_common_multiple

        Args:
            y (Self | int): `BIGINT | HUGEINT` expression

        Returns:
            Self
        """
        return self.__class__(func("lcm", self._expr, y))

    def least_common_multiple(self, y: Self | int) -> Self:
        """Computes the least common multiple of x and y.

        See Also:
            lcm

        Args:
            y (Self | int): `BIGINT | HUGEINT` expression

        Returns:
            Self
        """
        return self.__class__(func("least_common_multiple", self._expr, y))

    def len(self) -> Self:
        """Returns the bit-length of the `bit` argument.

        See Also:
            char_length, character_length, length

        Returns:
            Self
        """
        return self.__class__(func("len", self._expr))

    def length(self) -> Self:
        """Returns the bit-length of the `bit` argument.

        See Also:
            char_length, character_length, len

        Returns:
            Self
        """
        return self.__class__(func("length", self._expr))

    def lgamma(self) -> Self:
        """Computes the log of the gamma function.

        Returns:
            Self
        """
        return self.__class__(func("lgamma", self._expr))

    def list(self) -> Self:
        """Returns a LIST containing all the values of a column.

        See Also:
            array_agg

        Returns:
            Self
        """
        return self.__class__(func("list", self._expr))

    def listagg(self, arg: Self | str | None = None) -> Self:
        """Concatenates the column string values with an optional separator.

        See Also:
            group_concat, string_agg

        Args:
            arg (Self | str | None): `VARCHAR` expression

        Returns:
            Self
        """
        return self.__class__(func("listagg", self._expr, arg))

    def ln(self) -> Self:
        """Computes the natural logarithm of x.

        Returns:
            Self
        """
        return self.__class__(func("ln", self._expr))

    def log10(self) -> Self:
        """Computes the 10-log of x.

        Returns:
            Self
        """
        return self.__class__(func("log10", self._expr))

    def log2(self) -> Self:
        """Computes the 2-log of x.

        Returns:
            Self
        """
        return self.__class__(func("log2", self._expr))

    def mad(self) -> Self:
        """Returns the median absolute deviation for the values within x.

        NULL values are ignored.

        Temporal types return a positive INTERVAL.

        Returns:
            Self
        """
        return self.__class__(func("mad", self._expr))

    def make_date(self) -> Self:
        """The date for the given struct.

        Returns:
            Self
        """
        return self.__class__(func("make_date", self._expr))

    def make_date_month_day(
        self, month: Self | int | None = None, day: Self | int | None = None
    ) -> Self:
        """The date for the given parts.

        Args:
            month (Self | int | None): `BIGINT` expression
            day (Self | int | None): `BIGINT` expression

        Returns:
            Self
        """
        return self.__class__(func("make_date", self._expr, month, day))

    def make_time(self, minute: Self | int, seconds: Self | float) -> Self:
        """The time for the given parts.

        Args:
            minute (Self | int): `BIGINT` expression
            seconds (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("make_time", self._expr, minute, seconds))

    def make_timestamp(
        self,
        month: Self | int | None = None,
        day: Self | int | None = None,
        hour: Self | int | None = None,
        minute: Self | int | None = None,
        seconds: Self | float | None = None,
    ) -> Self:
        """The timestamp for the given parts.

        Args:
            month (Self | int | None): `BIGINT` expression
            day (Self | int | None): `BIGINT` expression
            hour (Self | int | None): `BIGINT` expression
            minute (Self | int | None): `BIGINT` expression
            seconds (Self | float | None): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(
            func("make_timestamp", self._expr, month, day, hour, minute, seconds)
        )

    def make_timestamp_ms(self) -> Self:
        """The timestamp for the given microseconds since the epoch.

        Returns:
            Self
        """
        return self.__class__(func("make_timestamp_ms", self._expr))

    def make_timestamp_ns(self) -> Self:
        """The timestamp for the given nanoseconds since epoch.

        Returns:
            Self
        """
        return self.__class__(func("make_timestamp_ns", self._expr))

    def make_timestamptz(
        self,
        col1: Self | int | None = None,
        col2: Self | int | None = None,
        col3: Self | int | None = None,
        col4: Self | int | None = None,
        col5: Self | float | None = None,
        col6: Self | str | None = None,
    ) -> Self:
        """SQL make_timestamptz function.

        Args:
            col1 (Self | int | None): `BIGINT` expression
            col2 (Self | int | None): `BIGINT` expression
            col3 (Self | int | None): `BIGINT` expression
            col4 (Self | int | None): `BIGINT` expression
            col5 (Self | float | None): `DOUBLE` expression
            col6 (Self | str | None): `VARCHAR` expression

        Returns:
            Self
        """
        return self.__class__(
            func("make_timestamptz", self._expr, col1, col2, col3, col4, col5, col6)
        )

    def map(self, values: Self) -> Self:
        """Creates a map from a set of keys and values.

        Args:
            values (Self): `V[]` expression

        Returns:
            Self
        """
        return self.__class__(func("map", self._expr, values))

    def map_concat(self, *args: Self) -> Self:
        """Returns a map created from merging the input maps, on key collision the value is taken from the last map with that key.

        Args:
            *args (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("map_concat", self._expr, *args))

    def map_contains(self, key: Self) -> Self:
        """Checks if a map contains a given key.

        Args:
            key (Self): `K` expression

        Returns:
            Self
        """
        return self.__class__(func("map_contains", self._expr, key))

    def map_contains_entry(self, key: Self, value: Self) -> Self:
        """SQL map_contains_entry function.

        Args:
            key (Self): `ANY` expression
            value (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("map_contains_entry", self._expr, key, value))

    def map_contains_value(self, value: Self) -> Self:
        """SQL map_contains_value function.

        Args:
            value (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("map_contains_value", self._expr, value))

    def map_entries(self) -> Self:
        """Returns the map entries as a list of keys/values.

        Returns:
            Self
        """
        return self.__class__(func("map_entries", self._expr))

    def map_extract(self, key: Self) -> Self:
        """Returns a list containing the value for a given key or an empty list if the key is not contained in the map.

        The type of the key provided in the second parameter must match the type of the map's keys else an error is returned.

        See Also:
            element_at

        Args:
            key (Self): `K` expression

        Returns:
            Self
        """
        return self.__class__(func("map_extract", self._expr, key))

    def map_extract_value(self, key: Self) -> Self:
        """Returns the value for a given key or NULL if the key is not contained in the map.

        The type of the key provided in the second parameter must match the type of the map's keys else an error is returned.

        Args:
            key (Self): `K` expression

        Returns:
            Self
        """
        return self.__class__(func("map_extract_value", self._expr, key))

    def map_from_entries(self) -> Self:
        """Returns a map created from the entries of the array.

        Returns:
            Self
        """
        return self.__class__(func("map_from_entries", self._expr))

    def map_keys(self) -> Self:
        """Returns the keys of a map as a list.

        Returns:
            Self
        """
        return self.__class__(func("map_keys", self._expr))

    def map_to_pg_oid(self) -> Self:
        """SQL map_to_pg_oid function.

        Returns:
            Self
        """
        return self.__class__(func("map_to_pg_oid", self._expr))

    def map_values(self) -> Self:
        """Returns the values of a map as a list.

        Returns:
            Self
        """
        return self.__class__(func("map_values", self._expr))

    def max(self, col1: Self | int | None = None) -> Self:
        """Returns the maximum value present in arg.

        Args:
            col1 (Self | int | None): `BIGINT` expression

        Returns:
            Self
        """
        return self.__class__(func("max", self._expr, col1))

    def max_by(
        self,
        val: Self | bytes | bytearray | memoryview | date | datetime | float | str,
        col2: Self | int | None = None,
    ) -> Self:
        """Finds the row with the maximum val.

        Calculates the non-NULL arg expression at that row.

        See Also:
            arg_max, argmax

        Args:
            val (Self | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DOUBLE | HUGEINT | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression
            col2 (Self | int | None): `BIGINT` expression

        Returns:
            Self
        """
        return self.__class__(func("max_by", self._expr, val, col2))

    def md5(self) -> Self:
        """Returns the MD5 hash of the `blob` as a `VARCHAR`.

        Returns:
            Self
        """
        return self.__class__(func("md5", self._expr))

    def md5_number(self) -> Self:
        """Returns the MD5 hash of the `blob` as a `HUGEINT`.

        Returns:
            Self
        """
        return self.__class__(func("md5_number", self._expr))

    def md5_number_lower(self) -> Self:
        """SQL md5_number_lower function.

        Returns:
            Self
        """
        return self.__class__(func("md5_number_lower", self._expr))

    def md5_number_upper(self) -> Self:
        """SQL md5_number_upper function.

        Returns:
            Self
        """
        return self.__class__(func("md5_number_upper", self._expr))

    def mean(self) -> Self:
        """Calculates the average value for all tuples in x.

        See Also:
            avg

        Returns:
            Self
        """
        return self.__class__(func("mean", self._expr))

    def median(self) -> Self:
        """Returns the middle value of the set.

        NULL values are ignored.

        For even value counts, interpolate-able types (numeric, date/time) return the average of the two middle values.

        Non-interpolate-able types (everything else) return the lower of the two middle values.

        Returns:
            Self
        """
        return self.__class__(func("median", self._expr))

    def microsecond(self) -> Self:
        """Extract the microsecond component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("microsecond", self._expr))

    def millennium(self) -> Self:
        """Extract the millennium component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("millennium", self._expr))

    def millisecond(self) -> Self:
        """Extract the millisecond component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("millisecond", self._expr))

    def min(self, col1: Self | int | None = None) -> Self:
        """Returns the minimum value present in arg.

        Args:
            col1 (Self | int | None): `BIGINT` expression

        Returns:
            Self
        """
        return self.__class__(func("min", self._expr, col1))

    def min_by(
        self,
        val: Self | bytes | bytearray | memoryview | date | datetime | float | str,
        col2: Self | int | None = None,
    ) -> Self:
        """Finds the row with the minimum val.

        Calculates the non-NULL arg expression at that row.

        See Also:
            arg_min, argmin

        Args:
            val (Self | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DOUBLE | HUGEINT | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression
            col2 (Self | int | None): `BIGINT` expression

        Returns:
            Self
        """
        return self.__class__(func("min_by", self._expr, val, col2))

    def minute(self) -> Self:
        """Extract the minute component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("minute", self._expr))

    def mod(self, col1: Self | Decimal | float) -> Self:
        """SQL mod function.

        Args:
            col1 (Self | Decimal | float | int): `BIGINT | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

        Returns:
            Self
        """
        return self.__class__(func("mod", self._expr, col1))

    def mode(self) -> Self:
        """Returns the most frequent value for the values within x.

        NULL values are ignored.

        Returns:
            Self
        """
        return self.__class__(func("mode", self._expr))

    def month(self) -> Self:
        """Extract the month component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("month", self._expr))

    def monthname(self) -> Self:
        """The (English) name of the month.

        Returns:
            Self
        """
        return self.__class__(func("monthname", self._expr))

    def multiply(self, col1: Self | Decimal | float | timedelta) -> Self:
        """SQL multiply function.

        Args:
            col1 (Self | Decimal | float | int | timedelta): `BIGINT | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | INTERVAL | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

        Returns:
            Self
        """
        return self.__class__(func("multiply", self._expr, col1))

    def nanosecond(self) -> Self:
        """Extract the nanosecond component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("nanosecond", self._expr))

    def nextafter(self, y: Self | float) -> Self:
        """Returns the next floating point value after x in the direction of y.

        Args:
            y (Self | float): `DOUBLE | FLOAT` expression

        Returns:
            Self
        """
        return self.__class__(func("nextafter", self._expr, y))

    def nextval(self) -> Self:
        """Return the following value of the sequence.

        Returns:
            Self
        """
        return self.__class__(func("nextval", self._expr))

    def normalized_interval(self) -> Self:
        """Normalizes an INTERVAL to an equivalent interval.

        Returns:
            Self
        """
        return self.__class__(func("normalized_interval", self._expr))

    def nullif(self, b: Self) -> Self:
        """SQL nullif function.

        Args:
            b (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("nullif", self._expr, b))

    def obj_description(self, catalog_name: Self) -> Self:
        """SQL obj_description function.

        Args:
            catalog_name (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("obj_description", self._expr, catalog_name))

    def octet_length(self) -> Self:
        """Number of bytes in `blob`.

        Returns:
            Self
        """
        return self.__class__(func("octet_length", self._expr))

    def parse_duckdb_log_message(self, message: Self | str) -> Self:
        """Parse the message into the expected logical type.

        Args:
            message (Self | str): `VARCHAR` expression

        Returns:
            Self
        """
        return self.__class__(func("parse_duckdb_log_message", self._expr, message))

    def pow(self, y: Self | float) -> Self:
        """Computes x to the power of y.

        See Also:
            power

        Args:
            y (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("pow", self._expr, y))

    def power(self, y: Self | float) -> Self:
        """Computes x to the power of y.

        See Also:
            pow

        Args:
            y (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("power", self._expr, y))

    def product(self) -> Self:
        """Calculates the product of all tuples in arg.

        Returns:
            Self
        """
        return self.__class__(func("product", self._expr))

    def quantile(self, pos: Self | float | list[float] | None = None) -> Self:
        """Returns the exact quantile number between 0 and 1 .

        If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.

        See Also:
            quantile_disc

        Args:
            pos (Self | float | list[float] | None): `DOUBLE | DOUBLE[]` expression

        Returns:
            Self
        """
        return self.__class__(func("quantile", self._expr, pos))

    def quantile_cont(self, pos: Self | float | list[float]) -> Self:
        """Returns the interpolated quantile number between 0 and 1 .

        If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.

        Args:
            pos (Self | float | list[float]): `DOUBLE | DOUBLE[]` expression

        Returns:
            Self
        """
        return self.__class__(func("quantile_cont", self._expr, pos))

    def quantile_disc(self, pos: Self | float | list[float] | None = None) -> Self:
        """Returns the exact quantile number between 0 and 1 .

        If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.

        See Also:
            quantile

        Args:
            pos (Self | float | list[float] | None): `DOUBLE | DOUBLE[]` expression

        Returns:
            Self
        """
        return self.__class__(func("quantile_disc", self._expr, pos))

    def quarter(self) -> Self:
        """Extract the quarter component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("quarter", self._expr))

    def radians(self) -> Self:
        """Converts degrees to radians.

        Returns:
            Self
        """
        return self.__class__(func("radians", self._expr))

    def regr_avgx(self, x: Self | float) -> Self:
        """Returns the average of the independent variable for non-NULL pairs in a group, where x is the independent variable and y is the dependent variable.

        Args:
            x (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("regr_avgx", self._expr, x))

    def regr_avgy(self, x: Self | float) -> Self:
        """Returns the average of the dependent variable for non-NULL pairs in a group, where x is the independent variable and y is the dependent variable.

        Args:
            x (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("regr_avgy", self._expr, x))

    def regr_count(self, x: Self | float) -> Self:
        """Returns the number of non-NULL number pairs in a group.

        Args:
            x (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("regr_count", self._expr, x))

    def regr_intercept(self, x: Self | float) -> Self:
        """Returns the intercept of the univariate linear regression line for non-NULL pairs in a group.

        Args:
            x (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("regr_intercept", self._expr, x))

    def regr_r2(self, x: Self | float) -> Self:
        """Returns the coefficient of determination for non-NULL pairs in a group.

        Args:
            x (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("regr_r2", self._expr, x))

    def regr_slope(self, x: Self | float) -> Self:
        """Returns the slope of the linear regression line for non-NULL pairs in a group.

        Args:
            x (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("regr_slope", self._expr, x))

    def regr_sxx(self, x: Self | float) -> Self:
        """SQL regr_sxx function.

        Args:
            x (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("regr_sxx", self._expr, x))

    def regr_sxy(self, x: Self | float) -> Self:
        """Returns the population covariance of input values.

        Args:
            x (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("regr_sxy", self._expr, x))

    def regr_syy(self, x: Self | float) -> Self:
        """SQL regr_syy function.

        Args:
            x (Self | float): `DOUBLE` expression

        Returns:
            Self
        """
        return self.__class__(func("regr_syy", self._expr, x))

    def remap_struct(self, target_type: Self, mapping: Self, defaults: Self) -> Self:
        """Map a struct to another struct type, potentially re-ordering, renaming and casting members and filling in defaults for missing values.

        Args:
            target_type (Self): `ANY` expression
            mapping (Self): `ANY` expression
            defaults (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(
            func("remap_struct", self._expr, target_type, mapping, defaults)
        )

    def repeat(self, count_2: Self | int) -> Self:
        """Repeats the `blob` `count` number of times.

        Args:
            count_2 (Self | int): `BIGINT` expression

        Returns:
            Self
        """
        return self.__class__(func("repeat", self._expr, count_2))

    def replace_type(self, type1: Self, type2: Self) -> Self:
        """Casts all fields of type1 to type2.

        Args:
            type1 (Self): `ANY` expression
            type2 (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("replace_type", self._expr, type1, type2))

    def reservoir_quantile(
        self,
        quantile: Self | float | list[float],
        sample_size: Self | int | None = None,
    ) -> Self:
        """Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.

        Args:
            quantile (Self | float | list[float]): `DOUBLE | DOUBLE[]` expression
            sample_size (Self | int | None): `INTEGER` expression

        Returns:
            Self
        """
        return self.__class__(
            func("reservoir_quantile", self._expr, quantile, sample_size)
        )

    def round(self, precision: Self | int | None = None) -> Self:
        """Rounds x to s decimal places.

        Args:
            precision (Self | int | None): `INTEGER` expression

        Returns:
            Self
        """
        return self.__class__(func("round", self._expr, precision))

    def round_even(self, n: Self) -> Self:
        """SQL round_even function.

        Args:
            n (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("round_even", self._expr, n))

    def roundbankers(self, n: Self) -> Self:
        """SQL roundbankers function.

        Args:
            n (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("roundbankers", self._expr, n))

    def row(self, *args: Self) -> Self:
        """Create an unnamed STRUCT (tuple) containing the argument values.

        Args:
            *args (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("row", self._expr, *args))

    def row_to_json(self, *args: Self) -> Self:
        """SQL row_to_json function.

        Args:
            *args (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("row_to_json", self._expr, *args))

    def second(self) -> Self:
        """Extract the second component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("second", self._expr))

    def sem(self) -> Self:
        """Returns the standard error of the mean.

        Returns:
            Self
        """
        return self.__class__(func("sem", self._expr))

    def set_bit(self, index: Self | int, new_value: Self | int) -> Self:
        """Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed 0.

        Returns a new bitstring.

        Args:
            index (Self | int): `INTEGER` expression
            new_value (Self | int): `INTEGER` expression

        Returns:
            Self
        """
        return self.__class__(func("set_bit", self._expr, index, new_value))

    def setseed(self) -> Self:
        """Sets the seed to be used for the random function.

        Returns:
            Self
        """
        return self.__class__(func("setseed", self._expr))

    def sha1(self) -> Self:
        """Returns a `VARCHAR` with the SHA-1 hash of the `blob`.

        Returns:
            Self
        """
        return self.__class__(func("sha1", self._expr))

    def sha256(self) -> Self:
        """Returns a `VARCHAR` with the SHA-256 hash of the `blob`.

        Returns:
            Self
        """
        return self.__class__(func("sha256", self._expr))

    def shobj_description(self, catalog_name: Self) -> Self:
        """SQL shobj_description function.

        Args:
            catalog_name (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("shobj_description", self._expr, catalog_name))

    def sign(self) -> Self:
        """Returns the sign of x as -1, 0 or 1.

        Returns:
            Self
        """
        return self.__class__(func("sign", self._expr))

    def signbit(self) -> Self:
        """Returns whether the signbit is set or not.

        Returns:
            Self
        """
        return self.__class__(func("signbit", self._expr))

    def sin(self) -> Self:
        """Computes the sin of x.

        Returns:
            Self
        """
        return self.__class__(func("sin", self._expr))

    def sinh(self) -> Self:
        """Computes the hyperbolic sin of x.

        Returns:
            Self
        """
        return self.__class__(func("sinh", self._expr))

    def skewness(self) -> Self:
        """Returns the skewness of all input values.

        Returns:
            Self
        """
        return self.__class__(func("skewness", self._expr))

    def split_part(self, delimiter: Self, position: Self) -> Self:
        """SQL split_part function.

        Args:
            delimiter (Self): `ANY` expression
            position (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("split_part", self._expr, delimiter, position))

    def sqrt(self) -> Self:
        """Returns the square root of x.

        Returns:
            Self
        """
        return self.__class__(func("sqrt", self._expr))

    def stats(self) -> Self:
        """Returns a string with statistics about the expression.

        Expression can be a column, constant, or SQL expression.

        Returns:
            Self
        """
        return self.__class__(func("stats", self._expr))

    def stddev(self) -> Self:
        """Returns the sample standard deviation.

        See Also:
            stddev_samp

        Returns:
            Self
        """
        return self.__class__(func("stddev", self._expr))

    def stddev_pop(self) -> Self:
        """Returns the population standard deviation.

        Returns:
            Self
        """
        return self.__class__(func("stddev_pop", self._expr))

    def stddev_samp(self) -> Self:
        """Returns the sample standard deviation.

        See Also:
            stddev

        Returns:
            Self
        """
        return self.__class__(func("stddev_samp", self._expr))

    def subtract(
        self, col1: Self | Decimal | date | datetime | float | timedelta | None = None
    ) -> Self:
        """SQL subtract function.

        Args:
            col1 (Self | Decimal | date | datetime | float | int | timedelta | None): `BIGINT | BIGNUM | DATE | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | INTERVAL | SMALLINT | TIMESTAMP | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

        Returns:
            Self
        """
        return self.__class__(func("subtract", self._expr, col1))

    def sum(self) -> Self:
        """Calculates the sum value for all tuples in arg.

        Returns:
            Self
        """
        return self.__class__(func("sum", self._expr))

    def sum_no_overflow(self) -> Self:
        """Internal only.

        Calculates the sum value for all tuples in arg without overflow checks.

        Returns:
            Self
        """
        return self.__class__(func("sum_no_overflow", self._expr))

    def sumkahan(self) -> Self:
        """Calculates the sum using a more accurate floating point summation (Kahan Sum).

        See Also:
            fsum, kahan_sum

        Returns:
            Self
        """
        return self.__class__(func("sumkahan", self._expr))

    def tan(self) -> Self:
        """Computes the tan of x.

        Returns:
            Self
        """
        return self.__class__(func("tan", self._expr))

    def tanh(self) -> Self:
        """Computes the hyperbolic tan of x.

        Returns:
            Self
        """
        return self.__class__(func("tanh", self._expr))

    def time_bucket(
        self,
        timestamp: Self | date | datetime,
        origin: Self | date | datetime | str | timedelta | None = None,
    ) -> Self:
        """Truncate TIMESTAMPTZ by the specified interval bucket_width.

        Buckets are aligned relative to origin TIMESTAMPTZ.

        The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets.

        Args:
            timestamp (Self | date | datetime): `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
            origin (Self | date | datetime | str | timedelta | None): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression

        Returns:
            Self
        """
        return self.__class__(func("time_bucket", self._expr, timestamp, origin))

    def timetz_byte_comparable(self) -> Self:
        """Converts a TIME WITH TIME ZONE to an integer sort key.

        Returns:
            Self
        """
        return self.__class__(func("timetz_byte_comparable", self._expr))

    def timezone(self, col1: Self | datetime | None = None) -> Self:
        """Extract the timezone component from a date or timestamp.

        Args:
            col1 (Self | datetime | None): `TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

        Returns:
            Self
        """
        return self.__class__(func("timezone", self._expr, col1))

    def timezone_hour(self) -> Self:
        """Extract the timezone_hour component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("timezone_hour", self._expr))

    def timezone_minute(self) -> Self:
        """Extract the timezone_minute component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("timezone_minute", self._expr))

    def to_binary(self) -> Self:
        """Converts the `value` to binary representation.

        See Also:
            bin

        Returns:
            Self
        """
        return self.__class__(func("to_binary", self._expr))

    def to_centuries(self) -> Self:
        """Construct a century interval.

        Returns:
            Self
        """
        return self.__class__(func("to_centuries", self._expr))

    def to_days(self) -> Self:
        """Construct a day interval.

        Returns:
            Self
        """
        return self.__class__(func("to_days", self._expr))

    def to_decades(self) -> Self:
        """Construct a decade interval.

        Returns:
            Self
        """
        return self.__class__(func("to_decades", self._expr))

    def to_hex(self) -> Self:
        """Converts the `value` to `VARCHAR` using hexadecimal representation.

        See Also:
            hex

        Returns:
            Self
        """
        return self.__class__(func("to_hex", self._expr))

    def to_hours(self) -> Self:
        """Construct a hour interval.

        Returns:
            Self
        """
        return self.__class__(func("to_hours", self._expr))

    def to_json(self, *args: Self) -> Self:
        """SQL to_json function.

        Args:
            *args (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("to_json", self._expr, *args))

    def to_microseconds(self) -> Self:
        """Construct a microsecond interval.

        Returns:
            Self
        """
        return self.__class__(func("to_microseconds", self._expr))

    def to_millennia(self) -> Self:
        """Construct a millenium interval.

        Returns:
            Self
        """
        return self.__class__(func("to_millennia", self._expr))

    def to_milliseconds(self) -> Self:
        """Construct a millisecond interval.

        Returns:
            Self
        """
        return self.__class__(func("to_milliseconds", self._expr))

    def to_minutes(self) -> Self:
        """Construct a minute interval.

        Returns:
            Self
        """
        return self.__class__(func("to_minutes", self._expr))

    def to_months(self) -> Self:
        """Construct a month interval.

        Returns:
            Self
        """
        return self.__class__(func("to_months", self._expr))

    def to_quarters(self) -> Self:
        """Construct a quarter interval.

        Returns:
            Self
        """
        return self.__class__(func("to_quarters", self._expr))

    def to_seconds(self) -> Self:
        """Construct a second interval.

        Returns:
            Self
        """
        return self.__class__(func("to_seconds", self._expr))

    def to_timestamp(self) -> Self:
        """Converts secs since epoch to a timestamp with time zone.

        Returns:
            Self
        """
        return self.__class__(func("to_timestamp", self._expr))

    def to_weeks(self) -> Self:
        """Construct a week interval.

        Returns:
            Self
        """
        return self.__class__(func("to_weeks", self._expr))

    def to_years(self) -> Self:
        """Construct a year interval.

        Returns:
            Self
        """
        return self.__class__(func("to_years", self._expr))

    def trunc(self, col1: Self | int | None = None) -> Self:
        """Truncates the number.

        Args:
            col1 (Self | int | None): `INTEGER` expression

        Returns:
            Self
        """
        return self.__class__(func("trunc", self._expr, col1))

    def try_strptime(self, format_arg: Self | list[str] | str) -> Self:
        """Converts the `string` text to timestamp according to the format string.

        Returns `NULL` on failure.

        Args:
            format_arg (Self | list[str] | str): `VARCHAR | VARCHAR[]` expression

        Returns:
            Self
        """
        return self.__class__(func("try_strptime", self._expr, format_arg))

    def typeof(self) -> Self:
        """Returns the name of the data type of the result of the expression.

        Returns:
            Self
        """
        return self.__class__(func("typeof", self._expr))

    def union_extract(self, tag: Self | str) -> Self:
        """Extract the value with the named tags from the union.

        NULL if the tag is not currently selected.

        Args:
            tag (Self | str): `VARCHAR` expression

        Returns:
            Self
        """
        return self.__class__(func("union_extract", self._expr, tag))

    def union_tag(self) -> Self:
        """Retrieve the currently selected tag of the union as an ENUM.

        Returns:
            Self
        """
        return self.__class__(func("union_tag", self._expr))

    def union_value(self, *args: Self) -> Self:
        """Create a single member UNION containing the argument value.

        The tag of the value will be the bound variable name.

        Args:
            *args (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("union_value", self._expr, *args))

    def uuid_extract_timestamp(self) -> Self:
        """Extract the timestamp for the given UUID v7.

        Returns:
            Self
        """
        return self.__class__(func("uuid_extract_timestamp", self._expr))

    def uuid_extract_version(self) -> Self:
        """Extract a version for the given UUID.

        Returns:
            Self
        """
        return self.__class__(func("uuid_extract_version", self._expr))

    def var_pop(self) -> Self:
        """Returns the population variance.

        Returns:
            Self
        """
        return self.__class__(func("var_pop", self._expr))

    def var_samp(self) -> Self:
        """Returns the sample variance of all input values.

        See Also:
            variance

        Returns:
            Self
        """
        return self.__class__(func("var_samp", self._expr))

    def variance(self) -> Self:
        """Returns the sample variance of all input values.

        See Also:
            var_samp

        Returns:
            Self
        """
        return self.__class__(func("variance", self._expr))

    def variant_extract(self, col1: Self | int | str) -> Self:
        """SQL variant_extract function.

        Args:
            col1 (Self | int | str): `UINTEGER | VARCHAR` expression

        Returns:
            Self
        """
        return self.__class__(func("variant_extract", self._expr, col1))

    def variant_typeof(self) -> Self:
        """Returns the internal type of the `input_variant`.

        Returns:
            Self
        """
        return self.__class__(func("variant_typeof", self._expr))

    def vector_type(self) -> Self:
        """Returns the VectorType of a given column.

        Returns:
            Self
        """
        return self.__class__(func("vector_type", self._expr))

    def wavg(self, weight: Self) -> Self:
        """SQL wavg function.

        Args:
            weight (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("wavg", self._expr, weight))

    def week(self) -> Self:
        """Extract the week component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("week", self._expr))

    def weekday(self) -> Self:
        """Extract the weekday component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("weekday", self._expr))

    def weekofyear(self) -> Self:
        """Extract the weekofyear component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("weekofyear", self._expr))

    def weighted_avg(self, weight: Self) -> Self:
        """SQL weighted_avg function.

        Args:
            weight (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("weighted_avg", self._expr, weight))

    def write_log(self, *args: Self) -> Self:
        """Writes to the logger.

        Args:
            *args (Self): `ANY` expression

        Returns:
            Self
        """
        return self.__class__(func("write_log", self._expr, *args))

    def xor(self, right: Self | bytes | bytearray | memoryview | int) -> Self:
        """Bitwise XOR.

        Args:
            right (Self | bytes | bytearray | memoryview | int): `BIGINT | BIT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

        Returns:
            Self
        """
        return self.__class__(func("xor", self._expr, right))

    def year(self) -> Self:
        """Extract the year component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("year", self._expr))

    def yearweek(self) -> Self:
        """Extract the yearweek component from a date or timestamp.

        Returns:
            Self
        """
        return self.__class__(func("yearweek", self._expr))


class ListFns[T: Fns](NameSpaceHandler[T]):
    """Mixin providing auto-generated DuckDB list functions as methods."""

    def aggregate(self, function_name: T | str, *args: T) -> T:
        """Executes the aggregate function `function_name` on the elements of `list`.

        See Also:
            array_aggr, array_aggregate, list_aggr, list_aggregate

        Args:
            function_name (T | str): `VARCHAR` expression
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("aggregate", self._parent.inner(), function_name, *args)
        )

    def apply(self, lambda_arg: T) -> T:
        """Returns a list that is the result of applying the `lambda` function to each element of the input `list`.

        The return type is defined by the return type of the `lambda` function.

        See Also:
            array_apply, array_transform, list_apply, list_transform

        Args:
            lambda_arg (T): `LAMBDA` expression

        Returns:
            T
        """
        return self._parent.__class__(func("apply", self._parent.inner(), lambda_arg))

    def array_aggr(self, function_name: T | str, *args: T) -> T:
        """Executes the aggregate function `function_name` on the elements of `list`.

        See Also:
            aggregate, array_aggregate, list_aggr, list_aggregate

        Args:
            function_name (T | str): `VARCHAR` expression
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_aggr", self._parent.inner(), function_name, *args)
        )

    def array_aggregate(self, function_name: T | str, *args: T) -> T:
        """Executes the aggregate function `function_name` on the elements of `list`.

        See Also:
            aggregate, array_aggr, list_aggr, list_aggregate

        Args:
            function_name (T | str): `VARCHAR` expression
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_aggregate", self._parent.inner(), function_name, *args)
        )

    def array_apply(self, lambda_arg: T) -> T:
        """Returns a list that is the result of applying the `lambda` function to each element of the input `list`.

        The return type is defined by the return type of the `lambda` function.

        See Also:
            apply, array_transform, list_apply, list_transform

        Args:
            lambda_arg (T): `LAMBDA` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_apply", self._parent.inner(), lambda_arg)
        )

    def array_cat(self, *args: T) -> T:
        """Concatenates lists.

        `NULL` inputs are skipped.

        See also operator `||`.

        See Also:
            array_concat, list_cat, list_concat

        Args:
            *args (T): `ANY[]` expression

        Returns:
            T
        """
        return self._parent.__class__(func("array_cat", self._parent.inner(), *args))

    def array_concat(self, *args: T) -> T:
        """Concatenates lists.

        `NULL` inputs are skipped.

        See also operator `||`.

        See Also:
            array_cat, list_cat, list_concat

        Args:
            *args (T): `ANY[]` expression

        Returns:
            T
        """
        return self._parent.__class__(func("array_concat", self._parent.inner(), *args))

    def array_contains(self, element: T) -> T:
        """Returns true if the list contains the element.

        See Also:
            array_has, list_contains, list_has

        Args:
            element (T): `T` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_contains", self._parent.inner(), element)
        )

    def array_distinct(self) -> T:
        """Removes all duplicates and `NULL` values from a list.

        Does not preserve the original order.

        See Also:
            list_distinct

        Returns:
            T
        """
        return self._parent.__class__(func("array_distinct", self._parent.inner()))

    def array_filter(self, lambda_arg: T) -> T:
        """Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`.

        DuckDB must be able to cast the `lambda` function's return type to `BOOL`.

        The return type of `list_filter` is the same as the input list's.

        See Also:
            filter, list_filter

        Args:
            lambda_arg (T): `LAMBDA` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_filter", self._parent.inner(), lambda_arg)
        )

    def array_grade_up(
        self, col1: T | str | None = None, col2: T | str | None = None
    ) -> T:
        """Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.

        See Also:
            grade_up, list_grade_up

        Args:
            col1 (T | str | None): `VARCHAR` expression
            col2 (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_grade_up", self._parent.inner(), col1, col2)
        )

    def array_has(self, element: T) -> T:
        """Returns true if the list contains the element.

        See Also:
            array_contains, list_contains, list_has

        Args:
            element (T): `T` expression

        Returns:
            T
        """
        return self._parent.__class__(func("array_has", self._parent.inner(), element))

    def array_has_all(self, list2: T) -> T:
        """Returns true if all elements of list2 are in list1.

        NULLs are ignored.

        See Also:
            list_has_all

        Args:
            list2 (T): `T[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_has_all", self._parent.inner(), list2)
        )

    def array_has_any(self, list2: T) -> T:
        """Returns true if the lists have any element in common.

        NULLs are ignored.

        See Also:
            list_has_any

        Args:
            list2 (T): `T[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_has_any", self._parent.inner(), list2)
        )

    def array_indexof(self, element: T) -> T:
        """Returns the index of the `element` if the `list` contains the `element`.

        If the `element` is not found, it returns `NULL`.

        See Also:
            array_position, list_indexof, list_position

        Args:
            element (T): `T` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_indexof", self._parent.inner(), element)
        )

    def array_length(self) -> T:
        """Returns the length of the `list`.

        Returns:
            T
        """
        return self._parent.__class__(func("array_length", self._parent.inner()))

    def array_length_dimension(self, dimension: T | int | None = None) -> T:
        """`array_length` for lists with dimensions other than 1 not implemented.

        Args:
            dimension (T | int | None): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_length", self._parent.inner(), dimension)
        )

    def array_position(self, element: T) -> T:
        """Returns the index of the `element` if the `list` contains the `element`.

        If the `element` is not found, it returns `NULL`.

        See Also:
            array_indexof, list_indexof, list_position

        Args:
            element (T): `T` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_position", self._parent.inner(), element)
        )

    def array_reduce(self, lambda_arg: T, initial_value: T | None = None) -> T:
        """Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element.

        The `lambda` function has an optional `initial_value` argument.

        See Also:
            list_reduce, reduce

        Args:
            lambda_arg (T): `LAMBDA` expression
            initial_value (T | None): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_reduce", self._parent.inner(), lambda_arg, initial_value)
        )

    def array_resize(self, size: T, value: T | None = None) -> T:
        """Resizes the `list` to contain `size` elements.

        Initializes new elements with `value` or `NULL` if `value` is not set.

        See Also:
            list_resize

        Args:
            size (T): `ANY` expression
            value (T | None): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_resize", self._parent.inner(), size, value)
        )

    def array_reverse_sort(self, col1: T | str | None = None) -> T:
        """Sorts the elements of the list in reverse order.

        See Also:
            list_reverse_sort

        Args:
            col1 (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_reverse_sort", self._parent.inner(), col1)
        )

    def array_select(self, index_list: T | list[int]) -> T:
        """Returns a list based on the elements selected by the `index_list`.

        See Also:
            list_select

        Args:
            index_list (T | list[int]): `BIGINT[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_select", self._parent.inner(), index_list)
        )

    def array_slice(self, begin: T, end: T, step: T | int | None = None) -> T:
        """Extracts a sublist or substring using slice conventions.

        Negative values are accepted.

        See Also:
            list_slice

        Args:
            begin (T): `ANY` expression
            end (T): `ANY` expression
            step (T | int | None): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_slice", self._parent.inner(), begin, end, step)
        )

    def array_sort(self, col1: T | str | None = None, col2: T | str | None = None) -> T:
        """Sorts the elements of the list.

        See Also:
            list_sort

        Args:
            col1 (T | str | None): `VARCHAR` expression
            col2 (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_sort", self._parent.inner(), col1, col2)
        )

    def array_transform(self, lambda_arg: T) -> T:
        """Returns a list that is the result of applying the `lambda` function to each element of the input `list`.

        The return type is defined by the return type of the `lambda` function.

        See Also:
            apply, array_apply, list_apply, list_transform

        Args:
            lambda_arg (T): `LAMBDA` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_transform", self._parent.inner(), lambda_arg)
        )

    def array_unique(self) -> T:
        """Counts the unique elements of a `list`.

        See Also:
            list_unique

        Returns:
            T
        """
        return self._parent.__class__(func("array_unique", self._parent.inner()))

    def array_where(self, mask_list: T | list[bool]) -> T:
        """Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`.

        See Also:
            list_where

        Args:
            mask_list (T | list[bool]): `BOOLEAN[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_where", self._parent.inner(), mask_list)
        )

    def array_zip(self, *args: T) -> T:
        """Zips n `LIST`s to a new `LIST` whose length will be that of the longest list.

        Its elements are structs of n elements from each list `list_1`, , `list_n`, missing elements are replaced with `NULL`.

        If `truncate` is set, all lists are truncated to the smallest list length.

        See Also:
            list_zip

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("array_zip", self._parent.inner(), *args))

    def char_length(self) -> T:
        """Returns the length of the `list`.

        See Also:
            character_length, len, length

        Returns:
            T
        """
        return self._parent.__class__(func("char_length", self._parent.inner()))

    def character_length(self) -> T:
        """Returns the length of the `list`.

        See Also:
            char_length, len, length

        Returns:
            T
        """
        return self._parent.__class__(func("character_length", self._parent.inner()))

    def concat(self, *args: T) -> T:
        """Concatenates multiple strings or lists.

        `NULL` inputs are skipped.

        See also operator `||`.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("concat", self._parent.inner(), *args))

    def filter(self, lambda_arg: T) -> T:
        """Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`.

        DuckDB must be able to cast the `lambda` function's return type to `BOOL`.

        The return type of `list_filter` is the same as the input list's.

        See Also:
            array_filter, list_filter

        Args:
            lambda_arg (T): `LAMBDA` expression

        Returns:
            T
        """
        return self._parent.__class__(func("filter", self._parent.inner(), lambda_arg))

    def flatten(self) -> T:
        """Flattens a nested list by one level.

        Returns:
            T
        """
        return self._parent.__class__(func("flatten", self._parent.inner()))

    def generate_series(
        self,
        stop: T | datetime | int | None = None,
        step: T | int | timedelta | None = None,
    ) -> T:
        """Creates a list of values between `start` and `stop` - the stop parameter is inclusive.

        Args:
            stop (T | datetime | int | None): `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
            step (T | int | timedelta | None): `BIGINT | INTERVAL` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("generate_series", self._parent.inner(), stop, step)
        )

    def grade_up(self, col1: T | str | None = None, col2: T | str | None = None) -> T:
        """Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.

        See Also:
            array_grade_up, list_grade_up

        Args:
            col1 (T | str | None): `VARCHAR` expression
            col2 (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("grade_up", self._parent.inner(), col1, col2)
        )

    def len(self) -> T:
        """Returns the length of the `list`.

        See Also:
            char_length, character_length, length

        Returns:
            T
        """
        return self._parent.__class__(func("len", self._parent.inner()))

    def length(self) -> T:
        """Returns the length of the `list`.

        See Also:
            char_length, character_length, len

        Returns:
            T
        """
        return self._parent.__class__(func("length", self._parent.inner()))

    def list_aggr(self, function_name: T | str, *args: T) -> T:
        """Executes the aggregate function `function_name` on the elements of `list`.

        See Also:
            aggregate, array_aggr, array_aggregate, list_aggregate

        Args:
            function_name (T | str): `VARCHAR` expression
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_aggr", self._parent.inner(), function_name, *args)
        )

    def list_aggregate(self, function_name: T | str, *args: T) -> T:
        """Executes the aggregate function `function_name` on the elements of `list`.

        See Also:
            aggregate, array_aggr, array_aggregate, list_aggr

        Args:
            function_name (T | str): `VARCHAR` expression
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_aggregate", self._parent.inner(), function_name, *args)
        )

    def list_any_value(self) -> T:
        """SQL list_any_value function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_any_value", self._parent.inner()))

    def list_append(self, e: T) -> T:
        """SQL list_append function.

        Args:
            e (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("list_append", self._parent.inner(), e))

    def list_apply(self, lambda_arg: T) -> T:
        """Returns a list that is the result of applying the `lambda` function to each element of the input `list`.

        The return type is defined by the return type of the `lambda` function.

        See Also:
            apply, array_apply, array_transform, list_transform

        Args:
            lambda_arg (T): `LAMBDA` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_apply", self._parent.inner(), lambda_arg)
        )

    def list_approx_count_distinct(self) -> T:
        """SQL list_approx_count_distinct function.

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_approx_count_distinct", self._parent.inner())
        )

    def list_avg(self) -> T:
        """SQL list_avg function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_avg", self._parent.inner()))

    def list_bit_and(self) -> T:
        """SQL list_bit_and function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_bit_and", self._parent.inner()))

    def list_bit_or(self) -> T:
        """SQL list_bit_or function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_bit_or", self._parent.inner()))

    def list_bit_xor(self) -> T:
        """SQL list_bit_xor function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_bit_xor", self._parent.inner()))

    def list_bool_and(self) -> T:
        """SQL list_bool_and function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_bool_and", self._parent.inner()))

    def list_bool_or(self) -> T:
        """SQL list_bool_or function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_bool_or", self._parent.inner()))

    def list_cat(self, *args: T) -> T:
        """Concatenates lists.

        `NULL` inputs are skipped.

        See also operator `||`.

        See Also:
            array_cat, array_concat, list_concat

        Args:
            *args (T): `ANY[]` expression

        Returns:
            T
        """
        return self._parent.__class__(func("list_cat", self._parent.inner(), *args))

    def list_concat(self, *args: T) -> T:
        """Concatenates lists.

        `NULL` inputs are skipped.

        See also operator `||`.

        See Also:
            array_cat, array_concat, list_cat

        Args:
            *args (T): `ANY[]` expression

        Returns:
            T
        """
        return self._parent.__class__(func("list_concat", self._parent.inner(), *args))

    def list_contains(self, element: T) -> T:
        """Returns true if the list contains the element.

        See Also:
            array_contains, array_has, list_has

        Args:
            element (T): `T` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_contains", self._parent.inner(), element)
        )

    def list_cosine_distance(self, list2: T | list[float]) -> T:
        """Computes the cosine distance between two same-sized lists.

        Args:
            list2 (T | list[float]): `DOUBLE[] | FLOAT[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_cosine_distance", self._parent.inner(), list2)
        )

    def list_cosine_similarity(self, list2: T | list[float]) -> T:
        """Computes the cosine similarity between two same-sized lists.

        Args:
            list2 (T | list[float]): `DOUBLE[] | FLOAT[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_cosine_similarity", self._parent.inner(), list2)
        )

    def list_count(self) -> T:
        """SQL list_count function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_count", self._parent.inner()))

    def list_distance(self, list2: T | list[float]) -> T:
        """Calculates the Euclidean distance between two points with coordinates given in two inputs lists of equal length.

        Args:
            list2 (T | list[float]): `DOUBLE[] | FLOAT[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_distance", self._parent.inner(), list2)
        )

    def list_distinct(self) -> T:
        """Removes all duplicates and `NULL` values from a list.

        Does not preserve the original order.

        See Also:
            array_distinct

        Returns:
            T
        """
        return self._parent.__class__(func("list_distinct", self._parent.inner()))

    def list_dot_product(self, list2: T | list[float]) -> T:
        """Computes the inner product between two same-sized lists.

        See Also:
            list_inner_product

        Args:
            list2 (T | list[float]): `DOUBLE[] | FLOAT[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_dot_product", self._parent.inner(), list2)
        )

    def list_element(self, index: T | int) -> T:
        """Extract the `index`th (1-based) value from the list.

        See Also:
            list_extract

        Args:
            index (T | int): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(func("list_element", self._parent.inner(), index))

    def list_entropy(self) -> T:
        """SQL list_entropy function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_entropy", self._parent.inner()))

    def list_extract(self, index: T | int) -> T:
        """Extract the `index`th (1-based) value from the list.

        See Also:
            list_element

        Args:
            index (T | int): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(func("list_extract", self._parent.inner(), index))

    def list_filter(self, lambda_arg: T) -> T:
        """Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`.

        DuckDB must be able to cast the `lambda` function's return type to `BOOL`.

        The return type of `list_filter` is the same as the input list's.

        See Also:
            array_filter, filter

        Args:
            lambda_arg (T): `LAMBDA` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_filter", self._parent.inner(), lambda_arg)
        )

    def list_first(self) -> T:
        """SQL list_first function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_first", self._parent.inner()))

    def list_grade_up(
        self, col1: T | str | None = None, col2: T | str | None = None
    ) -> T:
        """Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.

        See Also:
            array_grade_up, grade_up

        Args:
            col1 (T | str | None): `VARCHAR` expression
            col2 (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_grade_up", self._parent.inner(), col1, col2)
        )

    def list_has(self, element: T) -> T:
        """Returns true if the list contains the element.

        See Also:
            array_contains, array_has, list_contains

        Args:
            element (T): `T` expression

        Returns:
            T
        """
        return self._parent.__class__(func("list_has", self._parent.inner(), element))

    def list_has_all(self, list2: T) -> T:
        """Returns true if all elements of list2 are in list1.

        NULLs are ignored.

        See Also:
            array_has_all

        Args:
            list2 (T): `T[]` expression

        Returns:
            T
        """
        return self._parent.__class__(func("list_has_all", self._parent.inner(), list2))

    def list_has_any(self, list2: T) -> T:
        """Returns true if the lists have any element in common.

        NULLs are ignored.

        See Also:
            array_has_any

        Args:
            list2 (T): `T[]` expression

        Returns:
            T
        """
        return self._parent.__class__(func("list_has_any", self._parent.inner(), list2))

    def list_histogram(self) -> T:
        """SQL list_histogram function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_histogram", self._parent.inner()))

    def list_indexof(self, element: T) -> T:
        """Returns the index of the `element` if the `list` contains the `element`.

        If the `element` is not found, it returns `NULL`.

        See Also:
            array_indexof, array_position, list_position

        Args:
            element (T): `T` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_indexof", self._parent.inner(), element)
        )

    def list_inner_product(self, list2: T | list[float]) -> T:
        """Computes the inner product between two same-sized lists.

        See Also:
            list_dot_product

        Args:
            list2 (T | list[float]): `DOUBLE[] | FLOAT[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_inner_product", self._parent.inner(), list2)
        )

    def list_intersect(self, l2: T) -> T:
        """SQL list_intersect function.

        Args:
            l2 (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("list_intersect", self._parent.inner(), l2))

    def list_kurtosis(self) -> T:
        """SQL list_kurtosis function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_kurtosis", self._parent.inner()))

    def list_kurtosis_pop(self) -> T:
        """SQL list_kurtosis_pop function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_kurtosis_pop", self._parent.inner()))

    def list_last(self) -> T:
        """SQL list_last function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_last", self._parent.inner()))

    def list_mad(self) -> T:
        """SQL list_mad function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_mad", self._parent.inner()))

    def list_max(self) -> T:
        """SQL list_max function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_max", self._parent.inner()))

    def list_median(self) -> T:
        """SQL list_median function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_median", self._parent.inner()))

    def list_min(self) -> T:
        """SQL list_min function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_min", self._parent.inner()))

    def list_mode(self) -> T:
        """SQL list_mode function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_mode", self._parent.inner()))

    def list_negative_dot_product(self, list2: T | list[float]) -> T:
        """Computes the negative inner product between two same-sized lists.

        See Also:
            list_negative_inner_product

        Args:
            list2 (T | list[float]): `DOUBLE[] | FLOAT[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_negative_dot_product", self._parent.inner(), list2)
        )

    def list_negative_inner_product(self, list2: T | list[float]) -> T:
        """Computes the negative inner product between two same-sized lists.

        See Also:
            list_negative_dot_product

        Args:
            list2 (T | list[float]): `DOUBLE[] | FLOAT[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_negative_inner_product", self._parent.inner(), list2)
        )

    def list_pack(self, *args: T) -> T:
        """Creates a LIST containing the argument values.

        See Also:
            list_value

        Args:
            *args (T): `T` expression

        Returns:
            T
        """
        return self._parent.__class__(func("list_pack", self._parent.inner(), *args))

    def list_position(self, element: T) -> T:
        """Returns the index of the `element` if the `list` contains the `element`.

        If the `element` is not found, it returns `NULL`.

        See Also:
            array_indexof, array_position, list_indexof

        Args:
            element (T): `T` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_position", self._parent.inner(), element)
        )

    def list_prepend(self, l_arg: T) -> T:
        """SQL list_prepend function.

        Args:
            l_arg (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("list_prepend", self._parent.inner(), l_arg))

    def list_product(self) -> T:
        """SQL list_product function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_product", self._parent.inner()))

    def list_reduce(self, lambda_arg: T, initial_value: T | None = None) -> T:
        """Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element.

        The `lambda` function has an optional `initial_value` argument.

        See Also:
            array_reduce, reduce

        Args:
            lambda_arg (T): `LAMBDA` expression
            initial_value (T | None): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_reduce", self._parent.inner(), lambda_arg, initial_value)
        )

    def list_resize(self, size: T, value: T | None = None) -> T:
        """Resizes the `list` to contain `size` elements.

        Initializes new elements with `value` or `NULL` if `value` is not set.

        See Also:
            array_resize

        Args:
            size (T): `ANY` expression
            value (T | None): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_resize", self._parent.inner(), size, value)
        )

    def list_reverse(self) -> T:
        """SQL list_reverse function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_reverse", self._parent.inner()))

    def list_reverse_sort(self, col1: T | str | None = None) -> T:
        """Sorts the elements of the list in reverse order.

        See Also:
            array_reverse_sort

        Args:
            col1 (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_reverse_sort", self._parent.inner(), col1)
        )

    def list_select(self, index_list: T | list[int]) -> T:
        """Returns a list based on the elements selected by the `index_list`.

        See Also:
            array_select

        Args:
            index_list (T | list[int]): `BIGINT[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_select", self._parent.inner(), index_list)
        )

    def list_sem(self) -> T:
        """SQL list_sem function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_sem", self._parent.inner()))

    def list_skewness(self) -> T:
        """SQL list_skewness function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_skewness", self._parent.inner()))

    def list_slice(self, begin: T, end: T, step: T | int | None = None) -> T:
        """Extracts a sublist or substring using slice conventions.

        Negative values are accepted.

        See Also:
            array_slice

        Args:
            begin (T): `ANY` expression
            end (T): `ANY` expression
            step (T | int | None): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_slice", self._parent.inner(), begin, end, step)
        )

    def list_sort(self, col1: T | str | None = None, col2: T | str | None = None) -> T:
        """Sorts the elements of the list.

        See Also:
            array_sort

        Args:
            col1 (T | str | None): `VARCHAR` expression
            col2 (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_sort", self._parent.inner(), col1, col2)
        )

    def list_stddev_pop(self) -> T:
        """SQL list_stddev_pop function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_stddev_pop", self._parent.inner()))

    def list_stddev_samp(self) -> T:
        """SQL list_stddev_samp function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_stddev_samp", self._parent.inner()))

    def list_string_agg(self) -> T:
        """SQL list_string_agg function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_string_agg", self._parent.inner()))

    def list_sum(self) -> T:
        """SQL list_sum function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_sum", self._parent.inner()))

    def list_transform(self, lambda_arg: T) -> T:
        """Returns a list that is the result of applying the `lambda` function to each element of the input `list`.

        The return type is defined by the return type of the `lambda` function.

        See Also:
            apply, array_apply, array_transform, list_apply

        Args:
            lambda_arg (T): `LAMBDA` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_transform", self._parent.inner(), lambda_arg)
        )

    def list_unique(self) -> T:
        """Counts the unique elements of a `list`.

        See Also:
            array_unique

        Returns:
            T
        """
        return self._parent.__class__(func("list_unique", self._parent.inner()))

    def list_value(self, *args: T) -> T:
        """Creates a LIST containing the argument values.

        See Also:
            list_pack

        Args:
            *args (T): `T` expression

        Returns:
            T
        """
        return self._parent.__class__(func("list_value", self._parent.inner(), *args))

    def list_var_pop(self) -> T:
        """SQL list_var_pop function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_var_pop", self._parent.inner()))

    def list_var_samp(self) -> T:
        """SQL list_var_samp function.

        Returns:
            T
        """
        return self._parent.__class__(func("list_var_samp", self._parent.inner()))

    def list_where(self, mask_list: T | list[bool]) -> T:
        """Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`.

        See Also:
            array_where

        Args:
            mask_list (T | list[bool]): `BOOLEAN[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("list_where", self._parent.inner(), mask_list)
        )

    def list_zip(self, *args: T) -> T:
        """Zips n `LIST`s to a new `LIST` whose length will be that of the longest list.

        Its elements are structs of n elements from each list `list_1`, , `list_n`, missing elements are replaced with `NULL`.

        If `truncate` is set, all lists are truncated to the smallest list length.

        See Also:
            array_zip

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("list_zip", self._parent.inner(), *args))

    def range(
        self,
        stop: T | datetime | int | None = None,
        step: T | int | timedelta | None = None,
    ) -> T:
        """Creates a list of values between `start` and `stop` - the stop parameter is exclusive.

        Args:
            stop (T | datetime | int | None): `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
            step (T | int | timedelta | None): `BIGINT | INTERVAL` expression

        Returns:
            T
        """
        return self._parent.__class__(func("range", self._parent.inner(), stop, step))

    def reduce(self, lambda_arg: T, initial_value: T | None = None) -> T:
        """Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element.

        The `lambda` function has an optional `initial_value` argument.

        See Also:
            array_reduce, list_reduce

        Args:
            lambda_arg (T): `LAMBDA` expression
            initial_value (T | None): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("reduce", self._parent.inner(), lambda_arg, initial_value)
        )

    def unpivot_list(self, *args: T) -> T:
        """Identical to list_value, but generated as part of unpivot for better error messages.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("unpivot_list", self._parent.inner(), *args))


class StructFns[T: Fns](NameSpaceHandler[T]):
    """Mixin providing auto-generated DuckDB struct functions as methods."""

    def array_extract(self, entry: T | int | str) -> T:
        """Extracts the named `entry` from the `STRUCT`.

        Args:
            entry (T | int | str): `BIGINT | VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_extract", self._parent.inner(), entry)
        )

    def struct_concat(self, *args: T) -> T:
        """Merge the multiple STRUCTs into a single STRUCT.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("struct_concat", self._parent.inner(), *args)
        )

    def struct_contains(self, entry: T) -> T:
        """Check if an unnamed STRUCT contains the value.

        See Also:
            struct_has

        Args:
            entry (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("struct_contains", self._parent.inner(), entry)
        )

    def struct_extract(self, entry: T | int | str) -> T:
        """Extract the named entry from the STRUCT.

        Args:
            entry (T | int | str): `BIGINT | VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("struct_extract", self._parent.inner(), entry)
        )

    def struct_extract_at(self, entry: T | int) -> T:
        """Extract the entry from the STRUCT by position (starts at 1!).

        Args:
            entry (T | int): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("struct_extract_at", self._parent.inner(), entry)
        )

    def struct_has(self, entry: T) -> T:
        """Check if an unnamed STRUCT contains the value.

        See Also:
            struct_contains

        Args:
            entry (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("struct_has", self._parent.inner(), entry))

    def struct_indexof(self, entry: T) -> T:
        """Get the position of the entry in an unnamed STRUCT, starting at 1.

        See Also:
            struct_position

        Args:
            entry (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("struct_indexof", self._parent.inner(), entry)
        )

    def struct_insert(self, *args: T) -> T:
        """Adds field(s)/value(s) to an existing STRUCT with the argument values.

        The entry name(s) will be the bound variable name(s).

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("struct_insert", self._parent.inner(), *args)
        )

    def struct_pack(self, *args: T) -> T:
        """Create a STRUCT containing the argument values.

        The entry name will be the bound variable name.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("struct_pack", self._parent.inner(), *args))

    def struct_position(self, entry: T) -> T:
        """Get the position of the entry in an unnamed STRUCT, starting at 1.

        See Also:
            struct_indexof

        Args:
            entry (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("struct_position", self._parent.inner(), entry)
        )

    def struct_update(self, *args: T) -> T:
        """Changes field(s)/value(s) to an existing STRUCT with the argument values.

        The entry name(s) will be the bound variable name(s).

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("struct_update", self._parent.inner(), *args)
        )


class StringFns[T: Fns](NameSpaceHandler[T]):
    """Mixin providing auto-generated DuckDB string functions as methods."""

    def array_extract(self, index: T | int) -> T:
        """Extracts a single character from a `string` using a (1-based) `index`.

        Args:
            index (T | int): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_extract", self._parent.inner(), index)
        )

    def ascii(self) -> T:
        """Returns an integer that represents the Unicode code point of the first character of the `string`.

        Returns:
            T
        """
        return self._parent.__class__(func("ascii", self._parent.inner()))

    def bar(
        self, min_arg: T | float, max_arg: T | float, width: T | float | None = None
    ) -> T:
        """Draws a band whose width is proportional to (`x - min`) and equal to `width` characters when `x` = `max`.

        `width` defaults to 80.

        Args:
            min_arg (T | float): `DOUBLE` expression
            max_arg (T | float): `DOUBLE` expression
            width (T | float | None): `DOUBLE` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("bar", self._parent.inner(), min_arg, max_arg, width)
        )

    def base64(self) -> T:
        """Converts a `blob` to a base64 encoded string.

        See Also:
            to_base64

        Returns:
            T
        """
        return self._parent.__class__(func("base64", self._parent.inner()))

    def bin(self) -> T:
        """Converts the `string` to binary representation.

        See Also:
            to_binary

        Returns:
            T
        """
        return self._parent.__class__(func("bin", self._parent.inner()))

    def bit_length(self) -> T:
        """Number of bits in a `string`.

        Returns:
            T
        """
        return self._parent.__class__(func("bit_length", self._parent.inner()))

    def char_length(self) -> T:
        """Number of characters in `string`.

        See Also:
            character_length, len, length

        Returns:
            T
        """
        return self._parent.__class__(func("char_length", self._parent.inner()))

    def character_length(self) -> T:
        """Number of characters in `string`.

        See Also:
            char_length, len, length

        Returns:
            T
        """
        return self._parent.__class__(func("character_length", self._parent.inner()))

    def chr(self) -> T:
        """Returns a character which is corresponding the ASCII code value or Unicode code point.

        Returns:
            T
        """
        return self._parent.__class__(func("chr", self._parent.inner()))

    def concat_ws(self, string: T, *args: T) -> T:
        """Concatenates many strings, separated by `separator`.

        `NULL` inputs are skipped.

        Args:
            string (T): `ANY` expression
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("concat_ws", self._parent.inner(), string, *args)
        )

    def contains(self, search_string: T | str) -> T:
        """Returns `true` if `search_string` is found within `string`.

        Args:
            search_string (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("contains", self._parent.inner(), search_string)
        )

    def damerau_levenshtein(self, s2: T | str) -> T:
        """Extension of Levenshtein distance to also include transposition of adjacent characters as an allowed edit operation.

        In other words, the minimum number of edit operations (insertions, deletions, substitutions or transpositions) required to change one string to another.

        Characters of different cases (e.g., `a` and `A`) are considered different.

        Args:
            s2 (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("damerau_levenshtein", self._parent.inner(), s2)
        )

    def editdist3(self, s2: T | str) -> T:
        """The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other.

        Characters of different cases (e.g., `a` and `A`) are considered different.

        See Also:
            levenshtein

        Args:
            s2 (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(func("editdist3", self._parent.inner(), s2))

    def ends_with(self, search_string: T | str) -> T:
        """Returns `true` if `string` ends with `search_string`.

        See Also:
            suffix

        Args:
            search_string (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("ends_with", self._parent.inner(), search_string)
        )

    def format(self, *args: T) -> T:
        """Formats a string using the fmt syntax.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("format", self._parent.inner(), *args))

    def format_bytes(self) -> T:
        """Converts `integer` to a human-readable representation using units based on powers of 2 (KiB, MiB, GiB, etc.).

        See Also:
            formatReadableSize

        Returns:
            T
        """
        return self._parent.__class__(func("format_bytes", self._parent.inner()))

    def formatreadabledecimalsize(self) -> T:
        """Converts `integer` to a human-readable representation using units based on powers of 10 (KB, MB, GB, etc.).

        Returns:
            T
        """
        return self._parent.__class__(
            func("formatReadableDecimalSize", self._parent.inner())
        )

    def formatreadablesize(self) -> T:
        """Converts `integer` to a human-readable representation using units based on powers of 2 (KiB, MiB, GiB, etc.).

        See Also:
            format_bytes

        Returns:
            T
        """
        return self._parent.__class__(func("formatReadableSize", self._parent.inner()))

    def from_base64(self) -> T:
        """Converts a base64 encoded `string` to a character string (`BLOB`).

        Returns:
            T
        """
        return self._parent.__class__(func("from_base64", self._parent.inner()))

    def from_binary(self) -> T:
        """Converts a `value` from binary representation to a blob.

        See Also:
            unbin

        Returns:
            T
        """
        return self._parent.__class__(func("from_binary", self._parent.inner()))

    def from_hex(self) -> T:
        """Converts a `value` from hexadecimal representation to a blob.

        See Also:
            unhex

        Returns:
            T
        """
        return self._parent.__class__(func("from_hex", self._parent.inner()))

    def greatest(self, *args: T) -> T:
        """Returns the largest value.

        For strings lexicographical ordering is used.

        Note that lowercase characters are considered larger than uppercase characters and collations are not supported.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("greatest", self._parent.inner(), *args))

    def hamming(self, s2: T | str) -> T:
        """The Hamming distance between to strings, i.e., the number of positions with different characters for two strings of equal length.

        Strings must be of equal length.

        Characters of different cases (e.g., `a` and `A`) are considered different.

        See Also:
            mismatches

        Args:
            s2 (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(func("hamming", self._parent.inner(), s2))

    def hash(self, *args: T) -> T:
        """Returns a `UBIGINT` with the hash of the `value`.

        Note that this is not a cryptographic hash.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("hash", self._parent.inner(), *args))

    def hex(self) -> T:
        """Converts the `string` to hexadecimal representation.

        See Also:
            to_hex

        Returns:
            T
        """
        return self._parent.__class__(func("hex", self._parent.inner()))

    def ilike_escape(self, like_specifier: T | str, escape_character: T | str) -> T:
        """Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching.

        `escape_character` is used to search for wildcard characters in the `string`.

        Args:
            like_specifier (T | str): `VARCHAR` expression
            escape_character (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("ilike_escape", self._parent.inner(), like_specifier, escape_character)
        )

    def instr(self, search_string: T | str) -> T:
        """Returns location of first occurrence of `search_string` in `string`, counting from 1.

        Returns 0 if no match found.

        See Also:
            position, strpos

        Args:
            search_string (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("instr", self._parent.inner(), search_string)
        )

    def jaccard(self, s2: T | str) -> T:
        """The Jaccard similarity between two strings.

        Characters of different cases (e.g., `a` and `A`) are considered different.

        Returns a number between 0 and 1.

        Args:
            s2 (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(func("jaccard", self._parent.inner(), s2))

    def jaro_similarity(self, s2: T | str, score_cutoff: T | float | None = None) -> T:
        """The Jaro similarity between two strings.

        Characters of different cases (e.g., `a` and `A`) are considered different.

        Returns a number between 0 and 1.

        For similarity < `score_cutoff`, 0 is returned instead.

        `score_cutoff` defaults to 0.

        Args:
            s2 (T | str): `VARCHAR` expression
            score_cutoff (T | float | None): `DOUBLE` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("jaro_similarity", self._parent.inner(), s2, score_cutoff)
        )

    def jaro_winkler_similarity(
        self, s2: T | str, score_cutoff: T | float | None = None
    ) -> T:
        """The Jaro-Winkler similarity between two strings.

        Characters of different cases (e.g., `a` and `A`) are considered different.

        Returns a number between 0 and 1.

        For similarity < `score_cutoff`, 0 is returned instead.

        `score_cutoff` defaults to 0.

        Args:
            s2 (T | str): `VARCHAR` expression
            score_cutoff (T | float | None): `DOUBLE` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("jaro_winkler_similarity", self._parent.inner(), s2, score_cutoff)
        )

    def lcase(self) -> T:
        """Converts `string` to lower case.

        See Also:
            lower

        Returns:
            T
        """
        return self._parent.__class__(func("lcase", self._parent.inner()))

    def least(self, *args: T) -> T:
        """Returns the smallest value.

        For strings lexicographical ordering is used.

        Note that uppercase characters are considered smaller than lowercase characters, and collations are not supported.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("least", self._parent.inner(), *args))

    def left(self, count: T | int) -> T:
        """Extracts the left-most count characters.

        Args:
            count (T | int): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(func("left", self._parent.inner(), count))

    def left_grapheme(self, count: T | int) -> T:
        """Extracts the left-most count grapheme clusters.

        Args:
            count (T | int): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("left_grapheme", self._parent.inner(), count)
        )

    def len(self) -> T:
        """Number of characters in `string`.

        See Also:
            char_length, character_length, length

        Returns:
            T
        """
        return self._parent.__class__(func("len", self._parent.inner()))

    def length(self) -> T:
        """Number of characters in `string`.

        See Also:
            char_length, character_length, len

        Returns:
            T
        """
        return self._parent.__class__(func("length", self._parent.inner()))

    def length_grapheme(self) -> T:
        """Number of grapheme clusters in `string`.

        Returns:
            T
        """
        return self._parent.__class__(func("length_grapheme", self._parent.inner()))

    def levenshtein(self, s2: T | str) -> T:
        """The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other.

        Characters of different cases (e.g., `a` and `A`) are considered different.

        See Also:
            editdist3

        Args:
            s2 (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(func("levenshtein", self._parent.inner(), s2))

    def like_escape(self, like_specifier: T | str, escape_character: T | str) -> T:
        """Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching.

        `escape_character` is used to search for wildcard characters in the `string`.

        Args:
            like_specifier (T | str): `VARCHAR` expression
            escape_character (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("like_escape", self._parent.inner(), like_specifier, escape_character)
        )

    def lower(self) -> T:
        """Converts `string` to lower case.

        See Also:
            lcase

        Returns:
            T
        """
        return self._parent.__class__(func("lower", self._parent.inner()))

    def lpad(self, count: T | int, character: T | str) -> T:
        """Pads the `string` with the `character` on the left until it has `count` characters.

        Truncates the `string` on the right if it has more than `count` characters.

        Args:
            count (T | int): `INTEGER` expression
            character (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("lpad", self._parent.inner(), count, character)
        )

    def ltrim(self, characters: T | str | None = None) -> T:
        """Removes any occurrences of any of the `characters` from the left side of the `string`.

        `characters` defaults to `space`.

        Args:
            characters (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(func("ltrim", self._parent.inner(), characters))

    def md5(self) -> T:
        """Returns the MD5 hash of the `string` as a `VARCHAR`.

        Returns:
            T
        """
        return self._parent.__class__(func("md5", self._parent.inner()))

    def md5_number(self) -> T:
        """Returns the MD5 hash of the `string` as a `HUGEINT`.

        Returns:
            T
        """
        return self._parent.__class__(func("md5_number", self._parent.inner()))

    def mismatches(self, s2: T | str) -> T:
        """The Hamming distance between to strings, i.e., the number of positions with different characters for two strings of equal length.

        Strings must be of equal length.

        Characters of different cases (e.g., `a` and `A`) are considered different.

        See Also:
            hamming

        Args:
            s2 (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(func("mismatches", self._parent.inner(), s2))

    def nfc_normalize(self) -> T:
        """Converts `string` to Unicode NFC normalized string.

        Useful for comparisons and ordering if text data is mixed between NFC normalized and not.

        Returns:
            T
        """
        return self._parent.__class__(func("nfc_normalize", self._parent.inner()))

    def not_ilike_escape(self, like_specifier: T | str, escape_character: T | str) -> T:
        """Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching.

        `escape_character` is used to search for wildcard characters in the `string`.

        Args:
            like_specifier (T | str): `VARCHAR` expression
            escape_character (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func(
                "not_ilike_escape",
                self._parent.inner(),
                like_specifier,
                escape_character,
            )
        )

    def not_like_escape(self, like_specifier: T | str, escape_character: T | str) -> T:
        """Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching.

        `escape_character` is used to search for wildcard characters in the `string`.

        Args:
            like_specifier (T | str): `VARCHAR` expression
            escape_character (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func(
                "not_like_escape",
                self._parent.inner(),
                like_specifier,
                escape_character,
            )
        )

    def ord(self) -> T:
        """Returns an `INTEGER` representing the `unicode` codepoint of the first character in the `string`.

        See Also:
            unicode

        Returns:
            T
        """
        return self._parent.__class__(func("ord", self._parent.inner()))

    def parse_dirname(self, separator: T | str | None = None) -> T:
        """Returns the top-level directory name from the given `path`.

        `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.

        Args:
            separator (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("parse_dirname", self._parent.inner(), separator)
        )

    def parse_dirpath(self, separator: T | str | None = None) -> T:
        """Returns the head of the `path` (the pathname until the last slash) similarly to Python's `os.path.dirname`.

        `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.

        Args:
            separator (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("parse_dirpath", self._parent.inner(), separator)
        )

    def parse_filename(
        self,
        trim_extension: T | bool | str | None = None,
        separator: T | str | None = None,
    ) -> T:
        """Returns the last component of the `path` similarly to Python's `os.path.basename` function.

        If `trim_extension` is `true`, the file extension will be removed (defaults to `false`).

        `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.

        Args:
            trim_extension (T | bool | str | None): `BOOLEAN | VARCHAR` expression
            separator (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("parse_filename", self._parent.inner(), trim_extension, separator)
        )

    def parse_path(self, separator: T | str | None = None) -> T:
        """Returns a list of the components (directories and filename) in the `path` similarly to Python's `pathlib.parts` function.

        `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.

        Args:
            separator (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("parse_path", self._parent.inner(), separator)
        )

    def position(self, search_string: T | str) -> T:
        """Returns location of first occurrence of `search_string` in `string`, counting from 1.

        Returns 0 if no match found.

        See Also:
            instr, strpos

        Args:
            search_string (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("position", self._parent.inner(), search_string)
        )

    def prefix(self, search_string: T | str) -> T:
        """Returns `true` if `string` starts with `search_string`.

        Args:
            search_string (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("prefix", self._parent.inner(), search_string)
        )

    def printf(self, *args: T) -> T:
        """Formats a `string` using printf syntax.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("printf", self._parent.inner(), *args))

    def regexp_escape(self) -> T:
        """Escapes special patterns to turn `string` into a regular expression similarly to Python's `re.escape` function.

        Returns:
            T
        """
        return self._parent.__class__(func("regexp_escape", self._parent.inner()))

    def regexp_extract(
        self,
        regex: T | str,
        group: T | int | None = None,
        options: T | str | None = None,
    ) -> T:
        """If `string` contains the `regex` pattern, returns the capturing group specified by optional parameter `group`; otherwise, returns the empty string.

        The `group` must be a constant value.

        If no `group` is given, it defaults to 0.

        A set of optional regex `options` can be set.

        Args:
            regex (T | str): `VARCHAR` expression
            group (T | int | None): `INTEGER` expression
            options (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("regexp_extract", self._parent.inner(), regex, group, options)
        )

    def regexp_extract_all(
        self,
        regex: T | str,
        group: T | int | None = None,
        options: T | str | None = None,
    ) -> T:
        """Finds non-overlapping occurrences of the `regex` in the `string` and returns the corresponding values of the capturing `group`.

        A set of optional regex `options` can be set.

        Args:
            regex (T | str): `VARCHAR` expression
            group (T | int | None): `INTEGER` expression
            options (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("regexp_extract_all", self._parent.inner(), regex, group, options)
        )

    def regexp_extract_name_list(
        self,
        regex: T | str,
        name_list: T | list[str] | None = None,
        options: T | str | None = None,
    ) -> T:
        """If `string` contains the `regex` pattern, returns the capturing groups as a struct with corresponding names from `name_list`; otherwise, returns a struct with the same keys and empty strings as values.

        A set of optional regex `options` can be set.

        Args:
            regex (T | str): `VARCHAR` expression
            name_list (T | list[str] | None): `VARCHAR[]` expression
            options (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("regexp_extract", self._parent.inner(), regex, name_list, options)
        )

    def regexp_full_match(self, regex: T | str, col2: T | str | None = None) -> T:
        """Returns `true` if the entire `string` matches the `regex`.

        A set of optional regex `options` can be set.

        Args:
            regex (T | str): `VARCHAR` expression
            col2 (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("regexp_full_match", self._parent.inner(), regex, col2)
        )

    def regexp_matches(self, regex: T | str, options: T | str | None = None) -> T:
        """Returns `true` if `string` contains the `regex`, `false` otherwise.

        A set of optional regex `options` can be set.

        Args:
            regex (T | str): `VARCHAR` expression
            options (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("regexp_matches", self._parent.inner(), regex, options)
        )

    def regexp_replace(
        self, regex: T | str, replacement: T | str, options: T | str | None = None
    ) -> T:
        """If `string` contains the `regex`, replaces the matching part with `replacement`.

        A set of optional regex `options` can be set.

        Args:
            regex (T | str): `VARCHAR` expression
            replacement (T | str): `VARCHAR` expression
            options (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("regexp_replace", self._parent.inner(), regex, replacement, options)
        )

    def regexp_split_to_array(
        self, regex: T | str, options: T | str | None = None
    ) -> T:
        """Splits the `string` along the `regex`.

        A set of optional regex `options` can be set.

        See Also:
            str_split_regex, string_split_regex

        Args:
            regex (T | str): `VARCHAR` expression
            options (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("regexp_split_to_array", self._parent.inner(), regex, options)
        )

    def regexp_split_to_table(self, pattern: T) -> T:
        """SQL regexp_split_to_table function.

        Args:
            pattern (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("regexp_split_to_table", self._parent.inner(), pattern)
        )

    def repeat(self, count: T | int) -> T:
        """Repeats the `string` `count` number of times.

        Args:
            count (T | int): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(func("repeat", self._parent.inner(), count))

    def replace(self, source: T | str, target: T | str) -> T:
        """Replaces any occurrences of the `source` with `target` in `string`.

        Args:
            source (T | str): `VARCHAR` expression
            target (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("replace", self._parent.inner(), source, target)
        )

    def reverse(self) -> T:
        """Reverses the `string`.

        Returns:
            T
        """
        return self._parent.__class__(func("reverse", self._parent.inner()))

    def right(self, count: T | int) -> T:
        """Extract the right-most `count` characters.

        Args:
            count (T | int): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(func("right", self._parent.inner(), count))

    def right_grapheme(self, count: T | int) -> T:
        """Extracts the right-most `count` grapheme clusters.

        Args:
            count (T | int): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("right_grapheme", self._parent.inner(), count)
        )

    def rpad(self, count: T | int, character: T | str) -> T:
        """Pads the `string` with the `character` on the right until it has `count` characters.

        Truncates the `string` on the right if it has more than `count` characters.

        Args:
            count (T | int): `INTEGER` expression
            character (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("rpad", self._parent.inner(), count, character)
        )

    def rtrim(self, characters: T | str | None = None) -> T:
        """Removes any occurrences of any of the `characters` from the right side of the `string`.

        `characters` defaults to `space`.

        Args:
            characters (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(func("rtrim", self._parent.inner(), characters))

    def sha1(self) -> T:
        """Returns a `VARCHAR` with the SHA-1 hash of the `value`.

        Returns:
            T
        """
        return self._parent.__class__(func("sha1", self._parent.inner()))

    def sha256(self) -> T:
        """Returns a `VARCHAR` with the SHA-256 hash of the `value`.

        Returns:
            T
        """
        return self._parent.__class__(func("sha256", self._parent.inner()))

    def split(self, separator: T | str) -> T:
        """Splits the `string` along the `separator`.

        See Also:
            str_split, string_split, string_to_array

        Args:
            separator (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(func("split", self._parent.inner(), separator))

    def starts_with(self, search_string: T | str) -> T:
        """Returns `true` if `string` begins with `search_string`.

        Args:
            search_string (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("starts_with", self._parent.inner(), search_string)
        )

    def str_split(self, separator: T | str) -> T:
        """Splits the `string` along the `separator`.

        See Also:
            split, string_split, string_to_array

        Args:
            separator (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("str_split", self._parent.inner(), separator)
        )

    def str_split_regex(self, regex: T | str, options: T | str | None = None) -> T:
        """Splits the `string` along the `regex`.

        A set of optional regex `options` can be set.

        See Also:
            regexp_split_to_array, string_split_regex

        Args:
            regex (T | str): `VARCHAR` expression
            options (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("str_split_regex", self._parent.inner(), regex, options)
        )

    def strftime(self, format_arg: T | date | datetime | str) -> T:
        """Converts a `date` to a string according to the format string.

        Args:
            format_arg (T | date | datetime | str): `DATE | TIMESTAMP | TIMESTAMP_NS | VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("strftime", self._parent.inner(), format_arg)
        )

    def string_agg(self, arg: T | str | None = None) -> T:
        """Concatenates the column string values with an optional separator.

        See Also:
            group_concat, listagg

        Args:
            arg (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(func("string_agg", self._parent.inner(), arg))

    def string_split(self, separator: T | str) -> T:
        """Splits the `string` along the `separator`.

        See Also:
            split, str_split, string_to_array

        Args:
            separator (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("string_split", self._parent.inner(), separator)
        )

    def string_split_regex(self, regex: T | str, options: T | str | None = None) -> T:
        """Splits the `string` along the `regex`.

        A set of optional regex `options` can be set.

        See Also:
            regexp_split_to_array, str_split_regex

        Args:
            regex (T | str): `VARCHAR` expression
            options (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("string_split_regex", self._parent.inner(), regex, options)
        )

    def string_to_array(self, separator: T | str) -> T:
        """Splits the `string` along the `separator`.

        See Also:
            split, str_split, string_split

        Args:
            separator (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("string_to_array", self._parent.inner(), separator)
        )

    def strip_accents(self) -> T:
        """Strips accents from `string`.

        Returns:
            T
        """
        return self._parent.__class__(func("strip_accents", self._parent.inner()))

    def strlen(self) -> T:
        """Number of bytes in `string`.

        Returns:
            T
        """
        return self._parent.__class__(func("strlen", self._parent.inner()))

    def strpos(self, search_string: T | str) -> T:
        """Returns location of first occurrence of `search_string` in `string`, counting from 1.

        Returns 0 if no match found.

        See Also:
            instr, position

        Args:
            search_string (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("strpos", self._parent.inner(), search_string)
        )

    def strptime(self, format_arg: T | list[str] | str) -> T:
        """Converts the `string` text to timestamp according to the format string.

        Throws an error on failure.

        To return `NULL` on failure, use try_strptime.

        Args:
            format_arg (T | list[str] | str): `VARCHAR | VARCHAR[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("strptime", self._parent.inner(), format_arg)
        )

    def substr(self, start: T | int, length: T | int | None = None) -> T:
        """Extracts substring starting from character `start` up to the end of the string.

        If optional argument `length` is set, extracts a substring of `length` characters instead.

        Note that a `start` value of `1` refers to the first character of the `string`.

        See Also:
            substring

        Args:
            start (T | int): `BIGINT` expression
            length (T | int | None): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("substr", self._parent.inner(), start, length)
        )

    def substring(self, start: T | int, length: T | int | None = None) -> T:
        """Extracts substring starting from character `start` up to the end of the string.

        If optional argument `length` is set, extracts a substring of `length` characters instead.

        Note that a `start` value of `1` refers to the first character of the `string`.

        See Also:
            substr

        Args:
            start (T | int): `BIGINT` expression
            length (T | int | None): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("substring", self._parent.inner(), start, length)
        )

    def substring_grapheme(self, start: T | int, length: T | int | None = None) -> T:
        """Extracts substring starting from grapheme clusters `start` up to the end of the string.

        If optional argument `length` is set, extracts a substring of `length` grapheme clusters instead.

        Note that a `start` value of `1` refers to the `first` character of the `string`.

        Args:
            start (T | int): `BIGINT` expression
            length (T | int | None): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("substring_grapheme", self._parent.inner(), start, length)
        )

    def suffix(self, search_string: T | str) -> T:
        """Returns `true` if `string` ends with `search_string`.

        See Also:
            ends_with

        Args:
            search_string (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("suffix", self._parent.inner(), search_string)
        )

    def to_base(self, radix: T | int, min_length: T | int | None = None) -> T:
        """Converts `number` to a string in the given base `radix`, optionally padding with leading zeros to `min_length`.

        Args:
            radix (T | int): `INTEGER` expression
            min_length (T | int | None): `INTEGER` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("to_base", self._parent.inner(), radix, min_length)
        )

    def to_base64(self) -> T:
        """Converts a `blob` to a base64 encoded string.

        See Also:
            base64

        Returns:
            T
        """
        return self._parent.__class__(func("to_base64", self._parent.inner()))

    def to_binary(self) -> T:
        """Converts the `string` to binary representation.

        See Also:
            bin

        Returns:
            T
        """
        return self._parent.__class__(func("to_binary", self._parent.inner()))

    def to_hex(self) -> T:
        """Converts the `string` to hexadecimal representation.

        See Also:
            hex

        Returns:
            T
        """
        return self._parent.__class__(func("to_hex", self._parent.inner()))

    def translate(self, from_arg: T | str, to: T | str) -> T:
        """Replaces each character in `string` that matches a character in the `from` set with the corresponding character in the `to` set.

        If `from` is longer than `to`, occurrences of the extra characters in `from` are deleted.

        Args:
            from_arg (T | str): `VARCHAR` expression
            to (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("translate", self._parent.inner(), from_arg, to)
        )

    def trim(self, characters: T | str | None = None) -> T:
        """Removes any occurrences of any of the `characters` from either side of the `string`.

        `characters` defaults to `space`.

        Args:
            characters (T | str | None): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(func("trim", self._parent.inner(), characters))

    def ucase(self) -> T:
        """Converts `string` to upper case.

        See Also:
            upper

        Returns:
            T
        """
        return self._parent.__class__(func("ucase", self._parent.inner()))

    def unbin(self) -> T:
        """Converts a `value` from binary representation to a blob.

        See Also:
            from_binary

        Returns:
            T
        """
        return self._parent.__class__(func("unbin", self._parent.inner()))

    def unhex(self) -> T:
        """Converts a `value` from hexadecimal representation to a blob.

        See Also:
            from_hex

        Returns:
            T
        """
        return self._parent.__class__(func("unhex", self._parent.inner()))

    def unicode(self) -> T:
        """Returns an `INTEGER` representing the `unicode` codepoint of the first character in the `string`.

        See Also:
            ord

        Returns:
            T
        """
        return self._parent.__class__(func("unicode", self._parent.inner()))

    def upper(self) -> T:
        """Converts `string` to upper case.

        See Also:
            ucase

        Returns:
            T
        """
        return self._parent.__class__(func("upper", self._parent.inner()))

    def url_decode(self) -> T:
        """Decodes a URL from a representation using Percent-Encoding.

        Returns:
            T
        """
        return self._parent.__class__(func("url_decode", self._parent.inner()))

    def url_encode(self) -> T:
        """Encodes a URL to a representation using Percent-Encoding.

        Returns:
            T
        """
        return self._parent.__class__(func("url_encode", self._parent.inner()))


class DateTimeFns[T: Fns](NameSpaceHandler[T]):
    """Mixin providing auto-generated DuckDB datetime functions as methods."""

    def date_add(self, interval: T) -> T:
        """SQL date_add function.

        Args:
            interval (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("date_add", self._parent.inner(), interval))

    def date_diff(
        self, startdate: T | date | datetime | time, enddate: T | date | datetime | time
    ) -> T:
        """The number of partition boundaries between the timestamps.

        Args:
            startdate (T | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
            enddate (T | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("date_diff", self._parent.inner(), startdate, enddate)
        )

    def date_part(self, col1: T | date | datetime | time | timedelta) -> T:
        """Get subfield (equivalent to extract).

        Args:
            col1 (T | date | datetime | time | timedelta): `DATE | INTERVAL | TIME | TIME_NS | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

        Returns:
            T
        """
        return self._parent.__class__(func("date_part", self._parent.inner(), col1))

    def date_sub(
        self, startdate: T | date | datetime | time, enddate: T | date | datetime | time
    ) -> T:
        """The number of complete partitions between the timestamps.

        Args:
            startdate (T | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
            enddate (T | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("date_sub", self._parent.inner(), startdate, enddate)
        )

    def date_trunc(self, timestamp: T | date | datetime | timedelta) -> T:
        """Truncate to specified precision.

        Args:
            timestamp (T | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("date_trunc", self._parent.inner(), timestamp)
        )

    def datediff(
        self, startdate: T | date | datetime | time, enddate: T | date | datetime | time
    ) -> T:
        """The number of partition boundaries between the timestamps.

        Args:
            startdate (T | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
            enddate (T | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("datediff", self._parent.inner(), startdate, enddate)
        )

    def datepart(self, col1: T | date | datetime | time | timedelta) -> T:
        """Get subfield (equivalent to extract).

        Args:
            col1 (T | date | datetime | time | timedelta): `DATE | INTERVAL | TIME | TIME_NS | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

        Returns:
            T
        """
        return self._parent.__class__(func("datepart", self._parent.inner(), col1))

    def datesub(
        self, startdate: T | date | datetime | time, enddate: T | date | datetime | time
    ) -> T:
        """The number of complete partitions between the timestamps.

        Args:
            startdate (T | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
            enddate (T | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("datesub", self._parent.inner(), startdate, enddate)
        )

    def datetrunc(self, timestamp: T | date | datetime | timedelta) -> T:
        """Truncate to specified precision.

        Args:
            timestamp (T | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("datetrunc", self._parent.inner(), timestamp)
        )

    def day(self) -> T:
        """Extract the day component from a date or timestamp.

        Returns:
            T
        """
        return self._parent.__class__(func("day", self._parent.inner()))

    def dayname(self) -> T:
        """The (English) name of the weekday.

        Returns:
            T
        """
        return self._parent.__class__(func("dayname", self._parent.inner()))

    def dayofmonth(self) -> T:
        """Extract the dayofmonth component from a date or timestamp.

        Returns:
            T
        """
        return self._parent.__class__(func("dayofmonth", self._parent.inner()))

    def dayofweek(self) -> T:
        """Extract the dayofweek component from a date or timestamp.

        Returns:
            T
        """
        return self._parent.__class__(func("dayofweek", self._parent.inner()))

    def dayofyear(self) -> T:
        """Extract the dayofyear component from a date or timestamp.

        Returns:
            T
        """
        return self._parent.__class__(func("dayofyear", self._parent.inner()))


class ArrayFns[T: Fns](NameSpaceHandler[T]):
    """Mixin providing auto-generated DuckDB array functions as methods."""

    def array_agg(self) -> T:
        """Returns a LIST containing all the values of a column.

        See Also:
            list

        Returns:
            T
        """
        return self._parent.__class__(func("array_agg", self._parent.inner()))

    def array_append(self, el: T) -> T:
        """SQL array_append function.

        Args:
            el (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("array_append", self._parent.inner(), el))

    def array_cosine_distance(self, array2: T | float) -> T:
        """Computes the cosine distance between two arrays of the same size.

        The array elements can not be `NULL`.

        The arrays can have any size as long as the size is the same for both arguments.

        Args:
            array2 (T | float): `DOUBLE[ANY] | FLOAT[ANY]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_cosine_distance", self._parent.inner(), array2)
        )

    def array_cosine_similarity(self, array2: T | float) -> T:
        """Computes the cosine similarity between two arrays of the same size.

        The array elements can not be `NULL`.

        The arrays can have any size as long as the size is the same for both arguments.

        Args:
            array2 (T | float): `DOUBLE[ANY] | FLOAT[ANY]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_cosine_similarity", self._parent.inner(), array2)
        )

    def array_cross_product(self, array_2: T | float) -> T:
        """Computes the cross product of two arrays of size 3.

        The array elements can not be `NULL`.

        Args:
            array_2 (T | float): `DOUBLE[3] | FLOAT[3]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_cross_product", self._parent.inner(), array_2)
        )

    def array_distance(self, array2: T | float) -> T:
        """Computes the distance between two arrays of the same size.

        The array elements can not be `NULL`.

        The arrays can have any size as long as the size is the same for both arguments.

        Args:
            array2 (T | float): `DOUBLE[ANY] | FLOAT[ANY]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_distance", self._parent.inner(), array2)
        )

    def array_dot_product(self, array2: T | float) -> T:
        """Computes the inner product between two arrays of the same size.

        The array elements can not be `NULL`.

        The arrays can have any size as long as the size is the same for both arguments.

        See Also:
            array_inner_product

        Args:
            array2 (T | float): `DOUBLE[ANY] | FLOAT[ANY]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_dot_product", self._parent.inner(), array2)
        )

    def array_extract(self, col1: T | int) -> T:
        """SQL array_extract function.

        Args:
            col1 (T | int): `BIGINT` expression

        Returns:
            T
        """
        return self._parent.__class__(func("array_extract", self._parent.inner(), col1))

    def array_inner_product(self, array2: T | float) -> T:
        """Computes the inner product between two arrays of the same size.

        The array elements can not be `NULL`.

        The arrays can have any size as long as the size is the same for both arguments.

        See Also:
            array_dot_product

        Args:
            array2 (T | float): `DOUBLE[ANY] | FLOAT[ANY]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_inner_product", self._parent.inner(), array2)
        )

    def array_intersect(self, l2: T) -> T:
        """SQL array_intersect function.

        Args:
            l2 (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("array_intersect", self._parent.inner(), l2))

    def array_negative_dot_product(self, array2: T | float) -> T:
        """Computes the negative inner product between two arrays of the same size.

        The array elements can not be `NULL`.

        The arrays can have any size as long as the size is the same for both arguments.

        See Also:
            array_negative_inner_product

        Args:
            array2 (T | float): `DOUBLE[ANY] | FLOAT[ANY]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_negative_dot_product", self._parent.inner(), array2)
        )

    def array_negative_inner_product(self, array2: T | float) -> T:
        """Computes the negative inner product between two arrays of the same size.

        The array elements can not be `NULL`.

        The arrays can have any size as long as the size is the same for both arguments.

        See Also:
            array_negative_dot_product

        Args:
            array2 (T | float): `DOUBLE[ANY] | FLOAT[ANY]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_negative_inner_product", self._parent.inner(), array2)
        )

    def array_pop_back(self) -> T:
        """SQL array_pop_back function.

        Returns:
            T
        """
        return self._parent.__class__(func("array_pop_back", self._parent.inner()))

    def array_pop_front(self) -> T:
        """SQL array_pop_front function.

        Returns:
            T
        """
        return self._parent.__class__(func("array_pop_front", self._parent.inner()))

    def array_prepend(self, arr: T) -> T:
        """SQL array_prepend function.

        Args:
            arr (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("array_prepend", self._parent.inner(), arr))

    def array_push_back(self, e: T) -> T:
        """SQL array_push_back function.

        Args:
            e (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("array_push_back", self._parent.inner(), e))

    def array_push_front(self, e: T) -> T:
        """SQL array_push_front function.

        Args:
            e (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("array_push_front", self._parent.inner(), e))

    def array_reverse(self) -> T:
        """SQL array_reverse function.

        Returns:
            T
        """
        return self._parent.__class__(func("array_reverse", self._parent.inner()))

    def array_to_json(self, *args: T) -> T:
        """SQL array_to_json function.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_to_json", self._parent.inner(), *args)
        )

    def array_to_string(self, sep: T) -> T:
        """SQL array_to_string function.

        Args:
            sep (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_to_string", self._parent.inner(), sep)
        )

    def array_to_string_comma_default(self, sep: T) -> T:
        """SQL array_to_string_comma_default function.

        Args:
            sep (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("array_to_string_comma_default", self._parent.inner(), sep)
        )

    def array_value(self, *args: T) -> T:
        """Creates an `ARRAY` containing the argument values.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("array_value", self._parent.inner(), *args))


class JsonFns[T: Fns](NameSpaceHandler[T]):
    """Mixin providing auto-generated DuckDB JSON functions as methods."""

    def json_array(self, *args: T) -> T:
        """SQL json_array function.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("json_array", self._parent.inner(), *args))

    def json_array_length(self, col1: T | list[str] | str | None = None) -> T:
        """SQL json_array_length function.

        Args:
            col1 (T | list[str] | str | None): `VARCHAR | VARCHAR[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("json_array_length", self._parent.inner(), col1)
        )

    def json_contains(self, col1: T | str) -> T:
        """SQL json_contains function.

        Args:
            col1 (T | str): `JSON | VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(func("json_contains", self._parent.inner(), col1))

    def json_deserialize_sql(self) -> T:
        """SQL json_deserialize_sql function.

        Returns:
            T
        """
        return self._parent.__class__(
            func("json_deserialize_sql", self._parent.inner())
        )

    def json_exists(self, col1: T | list[str] | str) -> T:
        """SQL json_exists function.

        Args:
            col1 (T | list[str] | str): `VARCHAR | VARCHAR[]` expression

        Returns:
            T
        """
        return self._parent.__class__(func("json_exists", self._parent.inner(), col1))

    def json_extract(self, col1: T | int | list[str] | str) -> T:
        """SQL json_extract function.

        Args:
            col1 (T | int | list[str] | str): `BIGINT | VARCHAR | VARCHAR[]` expression

        Returns:
            T
        """
        return self._parent.__class__(func("json_extract", self._parent.inner(), col1))

    def json_extract_path(self, col1: T | int | list[str] | str) -> T:
        """SQL json_extract_path function.

        Args:
            col1 (T | int | list[str] | str): `BIGINT | VARCHAR | VARCHAR[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("json_extract_path", self._parent.inner(), col1)
        )

    def json_extract_path_text(self, col1: T | int | list[str] | str) -> T:
        """SQL json_extract_path_text function.

        Args:
            col1 (T | int | list[str] | str): `BIGINT | VARCHAR | VARCHAR[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("json_extract_path_text", self._parent.inner(), col1)
        )

    def json_extract_string(self, col1: T | int | list[str] | str) -> T:
        """SQL json_extract_string function.

        Args:
            col1 (T | int | list[str] | str): `BIGINT | VARCHAR | VARCHAR[]` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("json_extract_string", self._parent.inner(), col1)
        )

    def json_group_array(self) -> T:
        """SQL json_group_array function.

        Returns:
            T
        """
        return self._parent.__class__(func("json_group_array", self._parent.inner()))

    def json_group_object(self, v: T) -> T:
        """SQL json_group_object function.

        Args:
            v (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("json_group_object", self._parent.inner(), v)
        )

    def json_group_structure(self) -> T:
        """SQL json_group_structure function.

        Returns:
            T
        """
        return self._parent.__class__(
            func("json_group_structure", self._parent.inner())
        )

    def json_keys(self, col1: T | list[str] | str | None = None) -> T:
        """SQL json_keys function.

        Args:
            col1 (T | list[str] | str | None): `VARCHAR | VARCHAR[]` expression

        Returns:
            T
        """
        return self._parent.__class__(func("json_keys", self._parent.inner(), col1))

    def json_merge_patch(self, col1: T | str, *args: T | str) -> T:
        """SQL json_merge_patch function.

        Args:
            col1 (T | str): `JSON` expression
            *args (T | str): `JSON` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("json_merge_patch", self._parent.inner(), col1, *args)
        )

    def json_object(self, *args: T) -> T:
        """SQL json_object function.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("json_object", self._parent.inner(), *args))

    def json_pretty(self) -> T:
        """SQL json_pretty function.

        Returns:
            T
        """
        return self._parent.__class__(func("json_pretty", self._parent.inner()))

    def json_quote(self, *args: T) -> T:
        """SQL json_quote function.

        Args:
            *args (T): `ANY` expression

        Returns:
            T
        """
        return self._parent.__class__(func("json_quote", self._parent.inner(), *args))

    def json_serialize_plan(
        self,
        col1: T | bool | None = None,
        col2: T | bool | None = None,
        col3: T | bool | None = None,
        col4: T | bool | None = None,
    ) -> T:
        """SQL json_serialize_plan function.

        Args:
            col1 (T | bool | None): `BOOLEAN` expression
            col2 (T | bool | None): `BOOLEAN` expression
            col3 (T | bool | None): `BOOLEAN` expression
            col4 (T | bool | None): `BOOLEAN` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("json_serialize_plan", self._parent.inner(), col1, col2, col3, col4)
        )

    def json_serialize_sql(
        self,
        col1: T | bool | None = None,
        col2: T | bool | None = None,
        col3: T | bool | None = None,
        col4: T | bool | None = None,
    ) -> T:
        """SQL json_serialize_sql function.

        Args:
            col1 (T | bool | None): `BOOLEAN` expression
            col2 (T | bool | None): `BOOLEAN` expression
            col3 (T | bool | None): `BOOLEAN` expression
            col4 (T | bool | None): `BOOLEAN` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("json_serialize_sql", self._parent.inner(), col1, col2, col3, col4)
        )

    def json_structure(self) -> T:
        """SQL json_structure function.

        Returns:
            T
        """
        return self._parent.__class__(func("json_structure", self._parent.inner()))

    def json_transform(self, col1: T | str) -> T:
        """SQL json_transform function.

        Args:
            col1 (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("json_transform", self._parent.inner(), col1)
        )

    def json_transform_strict(self, col1: T | str) -> T:
        """SQL json_transform_strict function.

        Args:
            col1 (T | str): `VARCHAR` expression

        Returns:
            T
        """
        return self._parent.__class__(
            func("json_transform_strict", self._parent.inner(), col1)
        )

    def json_type(self, col1: T | list[str] | str | None = None) -> T:
        """SQL json_type function.

        Args:
            col1 (T | list[str] | str | None): `VARCHAR | VARCHAR[]` expression

        Returns:
            T
        """
        return self._parent.__class__(func("json_type", self._parent.inner(), col1))

    def json_valid(self) -> T:
        """SQL json_valid function.

        Returns:
            T
        """
        return self._parent.__class__(func("json_valid", self._parent.inner()))

    def json_value(self, col1: T | int | list[str] | str) -> T:
        """SQL json_value function.

        Args:
            col1 (T | int | list[str] | str): `BIGINT | VARCHAR | VARCHAR[]` expression

        Returns:
            T
        """
        return self._parent.__class__(func("json_value", self._parent.inner(), col1))
