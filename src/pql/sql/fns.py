"""DuckDB SQL function wrappers with type hints.

This file is AUTO-GENERATED by scripts/generate_fns.py
Do not edit manually - regenerate with:
    uv run -m scripts/generate_fns.py

Functions are extracted from DuckDB's duckdb_functions() introspection.
"""

from __future__ import annotations

from datetime import date, datetime, time, timedelta
from decimal import Decimal

from ._core import SqlExpr, func

__all__ = [
    "abs",
    "acos",
    "acosh",
    "add",
    "age",
    "alias",
    "any_value",
    "approx_count_distinct",
    "approx_quantile",
    "approx_top_k",
    "arg_max",
    "arg_max_null",
    "arg_min",
    "arg_min_null",
    "array_append",
    "array_cosine_distance",
    "array_cosine_similarity",
    "array_cross_product",
    "array_distance",
    "array_extract",
    "array_inner_product",
    "array_intersect",
    "array_length",
    "array_length_dimension",
    "array_negative_inner_product",
    "array_pop_back",
    "array_pop_front",
    "array_prepend",
    "array_push_back",
    "array_push_front",
    "array_reverse",
    "array_to_json",
    "array_to_string",
    "array_to_string_comma_default",
    "array_value",
    "ascii",
    "asin",
    "asinh",
    "atan",
    "atan2",
    "atanh",
    "avg",
    "bar",
    "bit_and",
    "bit_count",
    "bit_or",
    "bit_position",
    "bit_xor",
    "bitstring",
    "bitstring_agg",
    "bitstring_octet_length",
    "blob_hex",
    "blob_md5",
    "blob_md5_number",
    "blob_octet_length",
    "blob_repeat",
    "blob_sha1",
    "blob_sha256",
    "bool_and",
    "bool_or",
    "can_cast_implicitly",
    "cardinality",
    "cast_to_type",
    "cbrt",
    "ceil",
    "century",
    "chr",
    "col_description",
    "combine",
    "concat",
    "concat_ws",
    "constant_or_null",
    "contains",
    "corr",
    "cos",
    "cosh",
    "cot",
    "count",
    "count_if",
    "covar_pop",
    "covar_samp",
    "create_sort_key",
    "cume_dist",
    "currval",
    "damerau_levenshtein",
    "date_add",
    "date_diff",
    "date_part",
    "date_sub",
    "date_trunc",
    "datediff",
    "datepart",
    "datesub",
    "datetrunc",
    "day",
    "dayname",
    "dayofmonth",
    "dayofweek",
    "dayofyear",
    "decade",
    "decode",
    "degrees",
    "dense_rank",
    "divide",
    "encode",
    "entropy",
    "enum_code",
    "enum_first",
    "enum_last",
    "enum_range",
    "enum_range_boundary",
    "epoch",
    "epoch_ms",
    "epoch_ns",
    "epoch_us",
    "equi_width_bins",
    "era",
    "error",
    "even",
    "exp",
    "factorial",
    "favg",
    "fdiv",
    "fill",
    "finalize",
    "first",
    "first_value",
    "flatten",
    "floor",
    "fmod",
    "format",
    "format_bytes",
    "format_pg_type",
    "format_type",
    "formatreadabledecimalsize",
    "from_base64",
    "from_json",
    "from_json_strict",
    "gamma",
    "generate_series",
    "generate_subscripts",
    "geomean",
    "geometric_mean",
    "get_bit",
    "get_block_size",
    "getvariable",
    "greatest",
    "greatest_common_divisor",
    "hamming",
    "hash",
    "histogram",
    "histogram_exact",
    "hour",
    "ilike_escape",
    "in_search_path",
    "instr",
    "is_histogram_other_bin",
    "isfinite",
    "isinf",
    "isnan",
    "isodow",
    "isoyear",
    "jaccard",
    "jaro_similarity",
    "jaro_winkler_similarity",
    "json",
    "json_array",
    "json_array_length",
    "json_contains",
    "json_deserialize_sql",
    "json_exists",
    "json_extract",
    "json_extract_path",
    "json_extract_path_text",
    "json_extract_string",
    "json_group_array",
    "json_group_object",
    "json_group_structure",
    "json_keys",
    "json_merge_patch",
    "json_object",
    "json_pretty",
    "json_quote",
    "json_serialize_plan",
    "json_serialize_sql",
    "json_structure",
    "json_transform",
    "json_transform_strict",
    "json_type",
    "json_valid",
    "json_value",
    "julian",
    "kahan_sum",
    "kurtosis",
    "kurtosis_pop",
    "lag",
    "last",
    "last_day",
    "last_value",
    "lead",
    "least",
    "least_common_multiple",
    "left",
    "left_grapheme",
    "length_grapheme",
    "levenshtein",
    "lgamma",
    "like_escape",
    "list_aggregate",
    "list_any_value",
    "list_append",
    "list_approx_count_distinct",
    "list_avg",
    "list_bit_and",
    "list_bit_or",
    "list_bit_xor",
    "list_bool_and",
    "list_bool_or",
    "list_concat",
    "list_contains",
    "list_cosine_distance",
    "list_cosine_similarity",
    "list_count",
    "list_distance",
    "list_distinct",
    "list_entropy",
    "list_extract",
    "list_filter",
    "list_first",
    "list_fn",
    "list_grade_up",
    "list_has_all",
    "list_has_any",
    "list_histogram",
    "list_inner_product",
    "list_intersect",
    "list_kurtosis",
    "list_kurtosis_pop",
    "list_last",
    "list_length",
    "list_list_slice",
    "list_mad",
    "list_max",
    "list_median",
    "list_min",
    "list_mode",
    "list_negative_inner_product",
    "list_position",
    "list_prepend",
    "list_product",
    "list_reduce",
    "list_resize",
    "list_reverse",
    "list_reverse_sort",
    "list_select",
    "list_sem",
    "list_skewness",
    "list_sort",
    "list_stddev_pop",
    "list_stddev_samp",
    "list_string_agg",
    "list_string_list_slice",
    "list_sum",
    "list_transform",
    "list_unique",
    "list_value",
    "list_var_pop",
    "list_var_samp",
    "list_where",
    "list_zip",
    "ln",
    "log",
    "log2",
    "log10",
    "lower",
    "lpad",
    "ltrim",
    "mad",
    "make_date",
    "make_date_month_day",
    "make_time",
    "make_timestamp",
    "make_timestamp_ms",
    "make_timestamp_ns",
    "make_timestamptz",
    "map",
    "map_concat",
    "map_contains",
    "map_contains_entry",
    "map_contains_value",
    "map_entries",
    "map_extract",
    "map_extract_value",
    "map_from_entries",
    "map_keys",
    "map_to_pg_oid",
    "map_values",
    "max",
    "md5_number_lower",
    "md5_number_upper",
    "median",
    "microsecond",
    "millennium",
    "millisecond",
    "min",
    "minute",
    "mod",
    "mode",
    "month",
    "monthname",
    "multiply",
    "nanosecond",
    "nextafter",
    "nextval",
    "nfc_normalize",
    "normalized_interval",
    "not_ilike_escape",
    "not_like_escape",
    "nth_value",
    "ntile",
    "nullif",
    "numeric_bin",
    "numeric_bit_length",
    "numeric_hex",
    "numeric_length",
    "obj_description",
    "parse_dirname",
    "parse_dirpath",
    "parse_duckdb_log_message",
    "parse_filename",
    "parse_path",
    "percent_rank",
    "pow",
    "power",
    "prefix",
    "printf",
    "product",
    "quantile_cont",
    "quantile_disc",
    "quarter",
    "radians",
    "range",
    "rank",
    "regexp_escape",
    "regexp_extract",
    "regexp_extract_all",
    "regexp_extract_name_list",
    "regexp_full_match",
    "regexp_matches",
    "regexp_replace",
    "regexp_split_to_table",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "remap_struct",
    "repeat",
    "replace",
    "replace_type",
    "reservoir_quantile",
    "reverse",
    "right",
    "right_grapheme",
    "round",
    "round_even",
    "roundbankers",
    "row",
    "row_number",
    "row_to_json",
    "rpad",
    "rtrim",
    "second",
    "sem",
    "set_bit",
    "setseed",
    "shobj_description",
    "sign",
    "signbit",
    "sin",
    "sinh",
    "skewness",
    "split_part",
    "sqrt",
    "starts_with",
    "stats",
    "stddev_pop",
    "stddev_samp",
    "strftime",
    "string_agg",
    "string_array_extract",
    "string_bin",
    "string_bit_length",
    "string_contains",
    "string_hex",
    "string_length",
    "string_md5",
    "string_md5_number",
    "string_repeat",
    "string_sha1",
    "string_sha256",
    "string_split",
    "string_split_regex",
    "strip_accents",
    "strlen",
    "strptime",
    "struct_array_extract",
    "struct_concat",
    "struct_contains",
    "struct_extract",
    "struct_extract_at",
    "struct_insert",
    "struct_pack",
    "struct_position",
    "struct_update",
    "substring",
    "substring_grapheme",
    "subtract",
    "suffix",
    "sum",
    "sum_no_overflow",
    "tan",
    "tanh",
    "time_bucket",
    "timetz_byte_comparable",
    "timezone",
    "timezone_hour",
    "timezone_minute",
    "to_base",
    "to_base64",
    "to_centuries",
    "to_days",
    "to_decades",
    "to_hours",
    "to_json",
    "to_microseconds",
    "to_millennia",
    "to_milliseconds",
    "to_minutes",
    "to_months",
    "to_quarters",
    "to_seconds",
    "to_timestamp",
    "to_weeks",
    "to_years",
    "translate",
    "trim",
    "trunc",
    "try_strptime",
    "typeof",
    "unbin",
    "unhex",
    "unicode",
    "union_extract",
    "union_tag",
    "union_value",
    "unpivot_list",
    "upper",
    "url_decode",
    "url_encode",
    "uuid_extract_timestamp",
    "uuid_extract_version",
    "var_pop",
    "var_samp",
    "variant_extract",
    "variant_typeof",
    "vector_type",
    "wavg",
    "week",
    "weekday",
    "weekofyear",
    "weighted_avg",
    "write_log",
    "xor",
    "year",
    "yearweek",
]

# ============================================================
# Aggregate
# ============================================================


def any_value(arg: SqlExpr | Decimal) -> SqlExpr:
    """Returns the first non-NULL value from arg.

    This function is affected by ordering.

    Args:
        arg (SqlExpr | Decimal | SqlExpr): `ANY | DECIMAL` expression

    Returns:
        SqlExpr
    """
    return func("any_value", arg)


def approx_count_distinct(any_arg: SqlExpr) -> SqlExpr:
    """Computes the approximate count of distinct elements using HyperLogLog.

    Args:
        any_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("approx_count_distinct", any_arg)


def approx_quantile(
    x: SqlExpr | Decimal | date | datetime | float | time,
    pos: SqlExpr | float | list[float],
) -> SqlExpr:
    """Computes the approximate quantile using T-Digest.

    Args:
        x (SqlExpr | Decimal | date | datetime | float | int | time): `BIGINT | DATE | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | SMALLINT | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TINYINT` expression
        pos (SqlExpr | float | list[float]): `FLOAT | FLOAT[]` expression

    Returns:
        SqlExpr
    """
    return func("approx_quantile", x, pos)


def approx_top_k(val: SqlExpr, k: SqlExpr | int) -> SqlExpr:
    """Finds the k approximately most occurring values in the data set.

    Args:
        val (SqlExpr): `ANY` expression
        k (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("approx_top_k", val, k)


def arg_max(
    arg: SqlExpr
    | Decimal
    | bytes
    | bytearray
    | memoryview
    | date
    | datetime
    | float
    | str,
    val: SqlExpr | bytes | bytearray | memoryview | date | datetime | float | str,
    col2: SqlExpr | int | None = None,
) -> SqlExpr:
    """Finds the row with the maximum val.

    Calculates the non-NULL arg expression at that row.

    Args:
        arg (SqlExpr | Decimal | SqlExpr | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DECIMAL | DOUBLE | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression
        val (SqlExpr | SqlExpr | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DOUBLE | HUGEINT | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression
        col2 (SqlExpr | int | None): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("arg_max", arg, val, col2)


def arg_max_null(
    arg: SqlExpr
    | Decimal
    | bytes
    | bytearray
    | memoryview
    | date
    | datetime
    | float
    | str,
    val: SqlExpr | bytes | bytearray | memoryview | date | datetime | float | str,
) -> SqlExpr:
    """Finds the row with the maximum val.

    Calculates the arg expression at that row.

    Args:
        arg (SqlExpr | Decimal | SqlExpr | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DECIMAL | DOUBLE | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression
        val (SqlExpr | SqlExpr | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DOUBLE | HUGEINT | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("arg_max_null", arg, val)


def arg_min(
    arg: SqlExpr
    | Decimal
    | bytes
    | bytearray
    | memoryview
    | date
    | datetime
    | float
    | str,
    val: SqlExpr | bytes | bytearray | memoryview | date | datetime | float | str,
    col2: SqlExpr | int | None = None,
) -> SqlExpr:
    """Finds the row with the minimum val.

    Calculates the non-NULL arg expression at that row.

    Args:
        arg (SqlExpr | Decimal | SqlExpr | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DECIMAL | DOUBLE | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression
        val (SqlExpr | SqlExpr | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DOUBLE | HUGEINT | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression
        col2 (SqlExpr | int | None): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("arg_min", arg, val, col2)


def arg_min_null(
    arg: SqlExpr
    | Decimal
    | bytes
    | bytearray
    | memoryview
    | date
    | datetime
    | float
    | str,
    val: SqlExpr | bytes | bytearray | memoryview | date | datetime | float | str,
) -> SqlExpr:
    """Finds the row with the minimum val.

    Calculates the arg expression at that row.

    Args:
        arg (SqlExpr | Decimal | SqlExpr | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DECIMAL | DOUBLE | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression
        val (SqlExpr | SqlExpr | bytes | bytearray | memoryview | date | datetime | float | int | str): `ANY | BIGINT | BLOB | DATE | DOUBLE | HUGEINT | INTEGER | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("arg_min_null", arg, val)


def avg(x: SqlExpr | Decimal | datetime | float | time | timedelta) -> SqlExpr:
    """Calculates the average value for all tuples in x.

    Args:
        x (SqlExpr | Decimal | datetime | float | int | time | timedelta): `BIGINT | DECIMAL | DOUBLE | HUGEINT | INTEGER | INTERVAL | SMALLINT | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("avg", x)


def bool_and(arg: SqlExpr | bool) -> SqlExpr:
    """Returns TRUE if every input value is TRUE, otherwise FALSE.

    Args:
        arg (SqlExpr | bool): `BOOLEAN` expression

    Returns:
        SqlExpr
    """
    return func("bool_and", arg)


def bool_or(arg: SqlExpr | bool) -> SqlExpr:
    """Returns TRUE if any input value is TRUE, otherwise FALSE.

    Args:
        arg (SqlExpr | bool): `BOOLEAN` expression

    Returns:
        SqlExpr
    """
    return func("bool_or", arg)


def corr(y: SqlExpr | float, x: SqlExpr | float) -> SqlExpr:
    """Returns the correlation coefficient for non-NULL pairs in a group.

    Args:
        y (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("corr", y, x)


def count(arg: SqlExpr) -> SqlExpr:
    """Returns the number of non-NULL values in arg.

    Args:
        arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("count", arg)


def count_if(arg: SqlExpr | bool) -> SqlExpr:
    """Counts the total number of TRUE values for a boolean column.

    Args:
        arg (SqlExpr | bool): `BOOLEAN` expression

    Returns:
        SqlExpr
    """
    return func("count_if", arg)


def covar_pop(y: SqlExpr | float, x: SqlExpr | float) -> SqlExpr:
    """Returns the population covariance of input values.

    Args:
        y (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("covar_pop", y, x)


def covar_samp(y: SqlExpr | float, x: SqlExpr | float) -> SqlExpr:
    """Returns the sample covariance for non-NULL pairs in a group.

    Args:
        y (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("covar_samp", y, x)


def entropy(x: SqlExpr) -> SqlExpr:
    """Returns the log-2 entropy of count input-values.

    Args:
        x (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("entropy", x)


def favg(x: SqlExpr | float) -> SqlExpr:
    """Calculates the average using a more accurate floating point summation (Kahan Sum).

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("favg", x)


def first(arg: SqlExpr | Decimal) -> SqlExpr:
    """Returns the first value (NULL or non-NULL) from arg.

    This function is affected by ordering.

    Args:
        arg (SqlExpr | Decimal | SqlExpr): `ANY | DECIMAL` expression

    Returns:
        SqlExpr
    """
    return func("first", arg)


def histogram(arg: SqlExpr, col1: SqlExpr | None = None) -> SqlExpr:
    """Returns a LIST of STRUCTs with the fields bucket and count.

    Args:
        arg (SqlExpr): `ANY` expression
        col1 (SqlExpr | None): `ANY[]` expression

    Returns:
        SqlExpr
    """
    return func("histogram", arg, col1)


def histogram_exact(arg: SqlExpr, bins: SqlExpr) -> SqlExpr:
    """Returns a LIST of STRUCTs with the fields bucket and count matching the buckets exactly.

    Args:
        arg (SqlExpr): `ANY` expression
        bins (SqlExpr): `ANY[]` expression

    Returns:
        SqlExpr
    """
    return func("histogram_exact", arg, bins)


def kahan_sum(arg: SqlExpr | float) -> SqlExpr:
    """Calculates the sum using a more accurate floating point summation (Kahan Sum).

    Args:
        arg (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("kahan_sum", arg)


def kurtosis(x: SqlExpr | float) -> SqlExpr:
    """Returns the excess kurtosis (Fisher's definition) of all input values, with a bias correction according to the sample size.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("kurtosis", x)


def kurtosis_pop(x: SqlExpr | float) -> SqlExpr:
    """Returns the excess kurtosis (Fisher's definition) of all input values, without bias correction.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("kurtosis_pop", x)


def last(arg: SqlExpr | Decimal) -> SqlExpr:
    """Returns the last value of a column.

    This function is affected by ordering.

    Args:
        arg (SqlExpr | Decimal | SqlExpr): `ANY | DECIMAL` expression

    Returns:
        SqlExpr
    """
    return func("last", arg)


def mad(x: SqlExpr | Decimal | date | datetime | float | time) -> SqlExpr:
    """Returns the median absolute deviation for the values within x.

    NULL values are ignored.

    Temporal types return a positive INTERVAL.

    Args:
        x (SqlExpr | Decimal | date | datetime | float | time): `DATE | DECIMAL | DOUBLE | FLOAT | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("mad", x)


def max(arg: SqlExpr, col1: SqlExpr | int | None = None) -> SqlExpr:
    """Returns the maximum value present in arg.

    Args:
        arg (SqlExpr): `ANY` expression
        col1 (SqlExpr | int | None): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("max", arg, col1)


def median(x: SqlExpr) -> SqlExpr:
    """Returns the middle value of the set.

    NULL values are ignored.

    For even value counts, interpolate-able types (numeric, date/time) return the average of the two middle values.

    Non-interpolate-able types (everything else) return the lower of the two middle values.

    Args:
        x (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("median", x)


def min(arg: SqlExpr, col1: SqlExpr | int | None = None) -> SqlExpr:
    """Returns the minimum value present in arg.

    Args:
        arg (SqlExpr): `ANY` expression
        col1 (SqlExpr | int | None): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("min", arg, col1)


def mode(x: SqlExpr) -> SqlExpr:
    """Returns the most frequent value for the values within x.

    NULL values are ignored.

    Args:
        x (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("mode", x)


def product(arg: SqlExpr | float) -> SqlExpr:
    """Calculates the product of all tuples in arg.

    Args:
        arg (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("product", arg)


def quantile_cont(
    x: SqlExpr | Decimal | date | datetime | float | time,
    pos: SqlExpr | float | list[float],
) -> SqlExpr:
    """Returns the interpolated quantile number between 0 and 1 .

    If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.

    Args:
        x (SqlExpr | Decimal | date | datetime | float | int | time): `BIGINT | DATE | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | SMALLINT | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TINYINT` expression
        pos (SqlExpr | float | list[float]): `DOUBLE | DOUBLE[]` expression

    Returns:
        SqlExpr
    """
    return func("quantile_cont", x, pos)


def quantile_disc(
    x: SqlExpr, pos: SqlExpr | float | list[float] | None = None
) -> SqlExpr:
    """Returns the exact quantile number between 0 and 1 .

    If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.

    Args:
        x (SqlExpr): `ANY` expression
        pos (SqlExpr | float | list[float] | None): `DOUBLE | DOUBLE[]` expression

    Returns:
        SqlExpr
    """
    return func("quantile_disc", x, pos)


def regr_avgx(y: SqlExpr | float, x: SqlExpr | float) -> SqlExpr:
    """Returns the average of the independent variable for non-NULL pairs in a group, where x is the independent variable and y is the dependent variable.

    Args:
        y (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("regr_avgx", y, x)


def regr_avgy(y: SqlExpr | float, x: SqlExpr | float) -> SqlExpr:
    """Returns the average of the dependent variable for non-NULL pairs in a group, where x is the independent variable and y is the dependent variable.

    Args:
        y (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("regr_avgy", y, x)


def regr_count(y: SqlExpr | float, x: SqlExpr | float) -> SqlExpr:
    """Returns the number of non-NULL number pairs in a group.

    Args:
        y (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("regr_count", y, x)


def regr_intercept(y: SqlExpr | float, x: SqlExpr | float) -> SqlExpr:
    """Returns the intercept of the univariate linear regression line for non-NULL pairs in a group.

    Args:
        y (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("regr_intercept", y, x)


def regr_r2(y: SqlExpr | float, x: SqlExpr | float) -> SqlExpr:
    """Returns the coefficient of determination for non-NULL pairs in a group.

    Args:
        y (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("regr_r2", y, x)


def regr_slope(y: SqlExpr | float, x: SqlExpr | float) -> SqlExpr:
    """Returns the slope of the linear regression line for non-NULL pairs in a group.

    Args:
        y (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("regr_slope", y, x)


def regr_sxx(y: SqlExpr | float, x: SqlExpr | float) -> SqlExpr:
    """SQL regr_sxx function.

    Args:
        y (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("regr_sxx", y, x)


def regr_sxy(y: SqlExpr | float, x: SqlExpr | float) -> SqlExpr:
    """Returns the population covariance of input values.

    Args:
        y (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("regr_sxy", y, x)


def regr_syy(y: SqlExpr | float, x: SqlExpr | float) -> SqlExpr:
    """SQL regr_syy function.

    Args:
        y (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("regr_syy", y, x)


def reservoir_quantile(
    x: SqlExpr | Decimal | float,
    quantile: SqlExpr | float | list[float],
    sample_size: SqlExpr | int | None = None,
) -> SqlExpr:
    """Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.

    Args:
        x (SqlExpr | Decimal | float | int): `BIGINT | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | SMALLINT | TINYINT` expression
        quantile (SqlExpr | float | list[float]): `DOUBLE | DOUBLE[]` expression
        sample_size (SqlExpr | int | None): `INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("reservoir_quantile", x, quantile, sample_size)


def sem(x: SqlExpr | float) -> SqlExpr:
    """Returns the standard error of the mean.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("sem", x)


def skewness(x: SqlExpr | float) -> SqlExpr:
    """Returns the skewness of all input values.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("skewness", x)


def stddev_pop(x: SqlExpr | float) -> SqlExpr:
    """Returns the population standard deviation.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("stddev_pop", x)


def stddev_samp(x: SqlExpr | float) -> SqlExpr:
    """Returns the sample standard deviation.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("stddev_samp", x)


def sum(arg: SqlExpr | Decimal | bool | float) -> SqlExpr:
    """Calculates the sum value for all tuples in arg.

    Args:
        arg (SqlExpr | Decimal | SqlExpr | bool | float | int): `BIGINT | BIGNUM | BOOLEAN | DECIMAL | DOUBLE | HUGEINT | INTEGER | SMALLINT` expression

    Returns:
        SqlExpr
    """
    return func("sum", arg)


def sum_no_overflow(arg: SqlExpr | Decimal | int) -> SqlExpr:
    """Internal only.

    Calculates the sum value for all tuples in arg without overflow checks.

    Args:
        arg (SqlExpr | Decimal | int): `BIGINT | DECIMAL | INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("sum_no_overflow", arg)


def var_pop(x: SqlExpr | float) -> SqlExpr:
    """Returns the population variance.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("var_pop", x)


def var_samp(x: SqlExpr | float) -> SqlExpr:
    """Returns the sample variance of all input values.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("var_samp", x)


# ============================================================
# Array
# ============================================================


def array_append(arr: SqlExpr, el: SqlExpr) -> SqlExpr:
    """SQL array_append function.

    Args:
        arr (SqlExpr): `ANY` expression
        el (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("array_append", arr, el)


def array_cosine_distance(array1: SqlExpr | float, array2: SqlExpr | float) -> SqlExpr:
    """Computes the cosine distance between two arrays of the same size.

    The array elements can not be `NULL`.

    The arrays can have any size as long as the size is the same for both arguments.

    Args:
        array1 (SqlExpr | float): `DOUBLE[ANY] | FLOAT[ANY]` expression
        array2 (SqlExpr | float): `DOUBLE[ANY] | FLOAT[ANY]` expression

    Returns:
        SqlExpr
    """
    return func("array_cosine_distance", array1, array2)


def array_cosine_similarity(
    array1: SqlExpr | float, array2: SqlExpr | float
) -> SqlExpr:
    """Computes the cosine similarity between two arrays of the same size.

    The array elements can not be `NULL`.

    The arrays can have any size as long as the size is the same for both arguments.

    Args:
        array1 (SqlExpr | float): `DOUBLE[ANY] | FLOAT[ANY]` expression
        array2 (SqlExpr | float): `DOUBLE[ANY] | FLOAT[ANY]` expression

    Returns:
        SqlExpr
    """
    return func("array_cosine_similarity", array1, array2)


def array_cross_product(array: SqlExpr | float, array_2: SqlExpr | float) -> SqlExpr:
    """Computes the cross product of two arrays of size 3.

    The array elements can not be `NULL`.

    Args:
        array (SqlExpr | float): `DOUBLE[3] | FLOAT[3]` expression
        array_2 (SqlExpr | float): `DOUBLE[3] | FLOAT[3]` expression

    Returns:
        SqlExpr
    """
    return func("array_cross_product", array, array_2)


def array_distance(array1: SqlExpr | float, array2: SqlExpr | float) -> SqlExpr:
    """Computes the distance between two arrays of the same size.

    The array elements can not be `NULL`.

    The arrays can have any size as long as the size is the same for both arguments.

    Args:
        array1 (SqlExpr | float): `DOUBLE[ANY] | FLOAT[ANY]` expression
        array2 (SqlExpr | float): `DOUBLE[ANY] | FLOAT[ANY]` expression

    Returns:
        SqlExpr
    """
    return func("array_distance", array1, array2)


def array_extract(col0: SqlExpr, col1: SqlExpr | int) -> SqlExpr:
    """SQL array_extract function.

    Args:
        col0 (SqlExpr): `T[]` expression
        col1 (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("array_extract", col0, col1)


def array_inner_product(array1: SqlExpr | float, array2: SqlExpr | float) -> SqlExpr:
    """Computes the inner product between two arrays of the same size.

    The array elements can not be `NULL`.

    The arrays can have any size as long as the size is the same for both arguments.

    Args:
        array1 (SqlExpr | float): `DOUBLE[ANY] | FLOAT[ANY]` expression
        array2 (SqlExpr | float): `DOUBLE[ANY] | FLOAT[ANY]` expression

    Returns:
        SqlExpr
    """
    return func("array_inner_product", array1, array2)


def array_intersect(l1: SqlExpr, l2: SqlExpr) -> SqlExpr:
    """SQL array_intersect function.

    Args:
        l1 (SqlExpr): `ANY` expression
        l2 (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("array_intersect", l1, l2)


def array_length(list_arg: SqlExpr) -> SqlExpr:
    """Returns the length of the `list`.

    Args:
        list_arg (SqlExpr): `ANY[]` expression

    Returns:
        SqlExpr
    """
    return func("array_length", list_arg)


def array_length_dimension(
    list_arg: SqlExpr, dimension: SqlExpr | int | None = None
) -> SqlExpr:
    """`array_length` for lists with dimensions other than 1 not implemented.

    Args:
        list_arg (SqlExpr): `ANY[]` expression
        dimension (SqlExpr | int | None): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("array_length", list_arg, dimension)


def array_negative_inner_product(
    array1: SqlExpr | float, array2: SqlExpr | float
) -> SqlExpr:
    """Computes the negative inner product between two arrays of the same size.

    The array elements can not be `NULL`.

    The arrays can have any size as long as the size is the same for both arguments.

    Args:
        array1 (SqlExpr | float): `DOUBLE[ANY] | FLOAT[ANY]` expression
        array2 (SqlExpr | float): `DOUBLE[ANY] | FLOAT[ANY]` expression

    Returns:
        SqlExpr
    """
    return func("array_negative_inner_product", array1, array2)


def array_pop_back(arr: SqlExpr) -> SqlExpr:
    """SQL array_pop_back function.

    Args:
        arr (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("array_pop_back", arr)


def array_pop_front(arr: SqlExpr) -> SqlExpr:
    """SQL array_pop_front function.

    Args:
        arr (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("array_pop_front", arr)


def array_prepend(el: SqlExpr, arr: SqlExpr) -> SqlExpr:
    """SQL array_prepend function.

    Args:
        el (SqlExpr): `ANY` expression
        arr (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("array_prepend", el, arr)


def array_push_back(arr: SqlExpr, e: SqlExpr) -> SqlExpr:
    """SQL array_push_back function.

    Args:
        arr (SqlExpr): `ANY` expression
        e (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("array_push_back", arr, e)


def array_push_front(arr: SqlExpr, e: SqlExpr) -> SqlExpr:
    """SQL array_push_front function.

    Args:
        arr (SqlExpr): `ANY` expression
        e (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("array_push_front", arr, e)


def array_reverse(l_arg: SqlExpr) -> SqlExpr:
    """SQL array_reverse function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("array_reverse", l_arg)


def array_to_json(*args: SqlExpr) -> SqlExpr:
    """SQL array_to_json function.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("array_to_json", *args)


def array_to_string(arr: SqlExpr, sep: SqlExpr) -> SqlExpr:
    """SQL array_to_string function.

    Args:
        arr (SqlExpr): `ANY` expression
        sep (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("array_to_string", arr, sep)


def array_to_string_comma_default(arr: SqlExpr, sep: SqlExpr) -> SqlExpr:
    """SQL array_to_string_comma_default function.

    Args:
        arr (SqlExpr): `ANY` expression
        sep (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("array_to_string_comma_default", arr, sep)


def array_value(*args: SqlExpr) -> SqlExpr:
    """Creates an `ARRAY` containing the argument values.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("array_value", *args)


# ============================================================
# Bitwise
# ============================================================


def bit_and(arg: SqlExpr | bytes | bytearray | memoryview | int) -> SqlExpr:
    """Returns the bitwise AND of all bits in a given expression.

    Args:
        arg (SqlExpr | bytes | bytearray | memoryview | int): `BIGINT | BIT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

    Returns:
        SqlExpr
    """
    return func("bit_and", arg)


def bit_count(x: SqlExpr | bytes | bytearray | memoryview | int) -> SqlExpr:
    """Returns the number of bits that are set.

    Args:
        x (SqlExpr | bytes | bytearray | memoryview | int): `BIGINT | BIT | HUGEINT | INTEGER | SMALLINT | TINYINT` expression

    Returns:
        SqlExpr
    """
    return func("bit_count", x)


def bit_or(arg: SqlExpr | bytes | bytearray | memoryview | int) -> SqlExpr:
    """Returns the bitwise OR of all bits in a given expression.

    Args:
        arg (SqlExpr | bytes | bytearray | memoryview | int): `BIGINT | BIT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

    Returns:
        SqlExpr
    """
    return func("bit_or", arg)


def bit_position(
    substring: SqlExpr | bytes | bytearray | memoryview,
    bitstring: SqlExpr | bytes | bytearray | memoryview,
) -> SqlExpr:
    """Returns first starting index of the specified substring within bits, or zero if it is not present.

    The first (leftmost) bit is indexed 1.

    Args:
        substring (SqlExpr | bytes | bytearray | memoryview): `BIT` expression
        bitstring (SqlExpr | bytes | bytearray | memoryview): `BIT` expression

    Returns:
        SqlExpr
    """
    return func("bit_position", substring, bitstring)


def bit_xor(arg: SqlExpr | bytes | bytearray | memoryview | int) -> SqlExpr:
    """Returns the bitwise XOR of all bits in a given expression.

    Args:
        arg (SqlExpr | bytes | bytearray | memoryview | int): `BIGINT | BIT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

    Returns:
        SqlExpr
    """
    return func("bit_xor", arg)


def bitstring(
    bitstring: SqlExpr | bytes | bytearray | memoryview | str, length: SqlExpr | int
) -> SqlExpr:
    """Pads the bitstring until the specified length.

    Args:
        bitstring (SqlExpr | bytes | bytearray | memoryview | str): `BIT | VARCHAR` expression
        length (SqlExpr | int): `INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("bitstring", bitstring, length)


def bitstring_agg(
    arg: SqlExpr | int,
    col1: SqlExpr | int | None = None,
    col2: SqlExpr | int | None = None,
) -> SqlExpr:
    """Returns a bitstring with bits set for each distinct value.

    Args:
        arg (SqlExpr | int): `BIGINT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression
        col1 (SqlExpr | int | None): `BIGINT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression
        col2 (SqlExpr | int | None): `BIGINT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

    Returns:
        SqlExpr
    """
    return func("bitstring_agg", arg, col1, col2)


def bitstring_octet_length(
    bitstring: SqlExpr | bytes | bytearray | memoryview,
) -> SqlExpr:
    """Returns the number of bytes in the `bitstring`.

    Args:
        bitstring (SqlExpr | bytes | bytearray | memoryview): `BIT` expression

    Returns:
        SqlExpr
    """
    return func("octet_length", bitstring)


# ============================================================
# Conversion
# ============================================================


def from_base64(string: SqlExpr | str) -> SqlExpr:
    """Converts a base64 encoded `string` to a character string (`BLOB`).

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("from_base64", string)


def from_json(col0: SqlExpr | str, col1: SqlExpr | str) -> SqlExpr:
    """SQL from_json function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("from_json", col0, col1)


def from_json_strict(col0: SqlExpr | str, col1: SqlExpr | str) -> SqlExpr:
    """SQL from_json_strict function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("from_json_strict", col0, col1)


def to_base(
    number: SqlExpr | int, radix: SqlExpr | int, min_length: SqlExpr | int | None = None
) -> SqlExpr:
    """Converts `number` to a string in the given base `radix`, optionally padding with leading zeros to `min_length`.

    Args:
        number (SqlExpr | int): `BIGINT` expression
        radix (SqlExpr | int): `INTEGER` expression
        min_length (SqlExpr | int | None): `INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("to_base", number, radix, min_length)


def to_base64(blob: SqlExpr | bytes | bytearray | memoryview) -> SqlExpr:
    """Converts a `blob` to a base64 encoded string.

    Args:
        blob (SqlExpr | bytes | bytearray | memoryview): `BLOB` expression

    Returns:
        SqlExpr
    """
    return func("to_base64", blob)


def to_centuries(integer: SqlExpr | int) -> SqlExpr:
    """Construct a century interval.

    Args:
        integer (SqlExpr | int): `BIGINT | INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("to_centuries", integer)


def to_days(integer: SqlExpr | int) -> SqlExpr:
    """Construct a day interval.

    Args:
        integer (SqlExpr | int): `BIGINT | INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("to_days", integer)


def to_decades(integer: SqlExpr | int) -> SqlExpr:
    """Construct a decade interval.

    Args:
        integer (SqlExpr | int): `BIGINT | INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("to_decades", integer)


def to_hours(integer: SqlExpr | int) -> SqlExpr:
    """Construct a hour interval.

    Args:
        integer (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("to_hours", integer)


def to_json(*args: SqlExpr) -> SqlExpr:
    """SQL to_json function.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("to_json", *args)


def to_microseconds(integer: SqlExpr | int) -> SqlExpr:
    """Construct a microsecond interval.

    Args:
        integer (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("to_microseconds", integer)


def to_millennia(integer: SqlExpr | int) -> SqlExpr:
    """Construct a millenium interval.

    Args:
        integer (SqlExpr | int): `BIGINT | INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("to_millennia", integer)


def to_milliseconds(double: SqlExpr | float) -> SqlExpr:
    """Construct a millisecond interval.

    Args:
        double (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("to_milliseconds", double)


def to_minutes(integer: SqlExpr | int) -> SqlExpr:
    """Construct a minute interval.

    Args:
        integer (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("to_minutes", integer)


def to_months(integer: SqlExpr | int) -> SqlExpr:
    """Construct a month interval.

    Args:
        integer (SqlExpr | int): `BIGINT | INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("to_months", integer)


def to_quarters(integer: SqlExpr | int) -> SqlExpr:
    """Construct a quarter interval.

    Args:
        integer (SqlExpr | int): `BIGINT | INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("to_quarters", integer)


def to_seconds(double: SqlExpr | float) -> SqlExpr:
    """Construct a second interval.

    Args:
        double (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("to_seconds", double)


def to_timestamp(sec: SqlExpr | float) -> SqlExpr:
    """Converts secs since epoch to a timestamp with time zone.

    Args:
        sec (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("to_timestamp", sec)


def to_weeks(integer: SqlExpr | int) -> SqlExpr:
    """Construct a week interval.

    Args:
        integer (SqlExpr | int): `BIGINT | INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("to_weeks", integer)


def to_years(integer: SqlExpr | int) -> SqlExpr:
    """Construct a year interval.

    Args:
        integer (SqlExpr | int): `BIGINT | INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("to_years", integer)


# ============================================================
# Date
# ============================================================


def date_add(date_arg: SqlExpr, interval: SqlExpr) -> SqlExpr:
    """SQL date_add function.

    Args:
        date_arg (SqlExpr): `ANY` expression
        interval (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("date_add", date_arg, interval)


def date_diff(
    part: SqlExpr | str,
    startdate: SqlExpr | date | datetime | time,
    enddate: SqlExpr | date | datetime | time,
) -> SqlExpr:
    """The number of partition boundaries between the timestamps.

    Args:
        part (SqlExpr | str): `VARCHAR` expression
        startdate (SqlExpr | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
        enddate (SqlExpr | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("date_diff", part, startdate, enddate)


def date_part(
    ts: SqlExpr | list[str] | str, col1: SqlExpr | date | datetime | time | timedelta
) -> SqlExpr:
    """Get subfield (equivalent to extract).

    Args:
        ts (SqlExpr | list[str] | str): `VARCHAR | VARCHAR[]` expression
        col1 (SqlExpr | date | datetime | time | timedelta): `DATE | INTERVAL | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME_NS` expression

    Returns:
        SqlExpr
    """
    return func("date_part", ts, col1)


def date_sub(
    part: SqlExpr | str,
    startdate: SqlExpr | date | datetime | time,
    enddate: SqlExpr | date | datetime | time,
) -> SqlExpr:
    """The number of complete partitions between the timestamps.

    Args:
        part (SqlExpr | str): `VARCHAR` expression
        startdate (SqlExpr | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
        enddate (SqlExpr | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("date_sub", part, startdate, enddate)


def date_trunc(
    part: SqlExpr | str, timestamp: SqlExpr | date | datetime | timedelta
) -> SqlExpr:
    """Truncate to specified precision.

    Args:
        part (SqlExpr | str): `VARCHAR` expression
        timestamp (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("date_trunc", part, timestamp)


def datediff(
    part: SqlExpr | str,
    startdate: SqlExpr | date | datetime | time,
    enddate: SqlExpr | date | datetime | time,
) -> SqlExpr:
    """The number of partition boundaries between the timestamps.

    Args:
        part (SqlExpr | str): `VARCHAR` expression
        startdate (SqlExpr | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
        enddate (SqlExpr | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("datediff", part, startdate, enddate)


def datepart(
    ts: SqlExpr | list[str] | str, col1: SqlExpr | date | datetime | time | timedelta
) -> SqlExpr:
    """Get subfield (equivalent to extract).

    Args:
        ts (SqlExpr | list[str] | str): `VARCHAR | VARCHAR[]` expression
        col1 (SqlExpr | date | datetime | time | timedelta): `DATE | INTERVAL | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME_NS` expression

    Returns:
        SqlExpr
    """
    return func("datepart", ts, col1)


def datesub(
    part: SqlExpr | str,
    startdate: SqlExpr | date | datetime | time,
    enddate: SqlExpr | date | datetime | time,
) -> SqlExpr:
    """The number of complete partitions between the timestamps.

    Args:
        part (SqlExpr | str): `VARCHAR` expression
        startdate (SqlExpr | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
        enddate (SqlExpr | date | datetime | time): `DATE | TIME | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("datesub", part, startdate, enddate)


def datetrunc(
    part: SqlExpr | str, timestamp: SqlExpr | date | datetime | timedelta
) -> SqlExpr:
    """Truncate to specified precision.

    Args:
        part (SqlExpr | str): `VARCHAR` expression
        timestamp (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("datetrunc", part, timestamp)


# ============================================================
# Enum
# ============================================================


def enum_code(enum: SqlExpr) -> SqlExpr:
    """Returns the numeric value backing the given enum value.

    Args:
        enum (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("enum_code", enum)


def enum_first(enum: SqlExpr) -> SqlExpr:
    """Returns the first value of the input enum type.

    Args:
        enum (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("enum_first", enum)


def enum_last(enum: SqlExpr) -> SqlExpr:
    """Returns the last value of the input enum type.

    Args:
        enum (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("enum_last", enum)


def enum_range(enum: SqlExpr) -> SqlExpr:
    """Returns all values of the input enum type as an array.

    Args:
        enum (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("enum_range", enum)


def enum_range_boundary(start: SqlExpr, end: SqlExpr) -> SqlExpr:
    """Returns the range between the two given enum values as an array.

    The values must be of the same enum type.

    When the first parameter is NULL, the result starts with the first value of the enum type.

    When the second parameter is NULL, the result ends with the last value of the enum type.

    Args:
        start (SqlExpr): `ANY` expression
        end (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("enum_range_boundary", start, end)


# ============================================================
# JSON
# ============================================================


def json(x: SqlExpr) -> SqlExpr:
    """SQL json function.

    Args:
        x (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("json", x)


def json_array(*args: SqlExpr) -> SqlExpr:
    """SQL json_array function.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("json_array", *args)


def json_array_length(
    col0: SqlExpr | str, col1: SqlExpr | list[str] | str | None = None
) -> SqlExpr:
    """SQL json_array_length function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | list[str] | str | None): `VARCHAR | VARCHAR[]` expression

    Returns:
        SqlExpr
    """
    return func("json_array_length", col0, col1)


def json_contains(col0: SqlExpr | str, col1: SqlExpr | str) -> SqlExpr:
    """SQL json_contains function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | str): `JSON | VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("json_contains", col0, col1)


def json_deserialize_sql(col0: SqlExpr | str) -> SqlExpr:
    """SQL json_deserialize_sql function.

    Args:
        col0 (SqlExpr | str): `JSON` expression

    Returns:
        SqlExpr
    """
    return func("json_deserialize_sql", col0)


def json_exists(col0: SqlExpr | str, col1: SqlExpr | list[str] | str) -> SqlExpr:
    """SQL json_exists function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | list[str] | str): `VARCHAR | VARCHAR[]` expression

    Returns:
        SqlExpr
    """
    return func("json_exists", col0, col1)


def json_extract(col0: SqlExpr | str, col1: SqlExpr | int | list[str] | str) -> SqlExpr:
    """SQL json_extract function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | int | list[str] | str): `BIGINT | VARCHAR | VARCHAR[]` expression

    Returns:
        SqlExpr
    """
    return func("json_extract", col0, col1)


def json_extract_path(
    col0: SqlExpr | str, col1: SqlExpr | int | list[str] | str
) -> SqlExpr:
    """SQL json_extract_path function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | int | list[str] | str): `BIGINT | VARCHAR | VARCHAR[]` expression

    Returns:
        SqlExpr
    """
    return func("json_extract_path", col0, col1)


def json_extract_path_text(
    col0: SqlExpr | str, col1: SqlExpr | int | list[str] | str
) -> SqlExpr:
    """SQL json_extract_path_text function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | int | list[str] | str): `BIGINT | VARCHAR | VARCHAR[]` expression

    Returns:
        SqlExpr
    """
    return func("json_extract_path_text", col0, col1)


def json_extract_string(
    col0: SqlExpr | str, col1: SqlExpr | int | list[str] | str
) -> SqlExpr:
    """SQL json_extract_string function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | int | list[str] | str): `BIGINT | VARCHAR | VARCHAR[]` expression

    Returns:
        SqlExpr
    """
    return func("json_extract_string", col0, col1)


def json_group_array(x: SqlExpr) -> SqlExpr:
    """SQL json_group_array function.

    Args:
        x (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("json_group_array", x)


def json_group_object(n: SqlExpr, v: SqlExpr) -> SqlExpr:
    """SQL json_group_object function.

    Args:
        n (SqlExpr): `ANY` expression
        v (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("json_group_object", n, v)


def json_group_structure(x: SqlExpr) -> SqlExpr:
    """SQL json_group_structure function.

    Args:
        x (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("json_group_structure", x)


def json_keys(
    col0: SqlExpr | str, col1: SqlExpr | list[str] | str | None = None
) -> SqlExpr:
    """SQL json_keys function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | list[str] | str | None): `VARCHAR | VARCHAR[]` expression

    Returns:
        SqlExpr
    """
    return func("json_keys", col0, col1)


def json_merge_patch(
    col0: SqlExpr | str, col1: SqlExpr | str, *args: SqlExpr | str
) -> SqlExpr:
    """SQL json_merge_patch function.

    Args:
        col0 (SqlExpr | str): `JSON` expression
        col1 (SqlExpr | str): `JSON` expression
        *args (SqlExpr | str): `JSON` expression

    Returns:
        SqlExpr
    """
    return func("json_merge_patch", col0, col1, *args)


def json_object(*args: SqlExpr) -> SqlExpr:
    """SQL json_object function.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("json_object", *args)


def json_pretty(col0: SqlExpr | str) -> SqlExpr:
    """SQL json_pretty function.

    Args:
        col0 (SqlExpr | str): `JSON` expression

    Returns:
        SqlExpr
    """
    return func("json_pretty", col0)


def json_quote(*args: SqlExpr) -> SqlExpr:
    """SQL json_quote function.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("json_quote", *args)


def json_serialize_plan(
    col0: SqlExpr | str,
    col1: SqlExpr | bool | None = None,
    col2: SqlExpr | bool | None = None,
    col3: SqlExpr | bool | None = None,
    col4: SqlExpr | bool | None = None,
) -> SqlExpr:
    """SQL json_serialize_plan function.

    Args:
        col0 (SqlExpr | str): `VARCHAR` expression
        col1 (SqlExpr | bool | None): `BOOLEAN` expression
        col2 (SqlExpr | bool | None): `BOOLEAN` expression
        col3 (SqlExpr | bool | None): `BOOLEAN` expression
        col4 (SqlExpr | bool | None): `BOOLEAN` expression

    Returns:
        SqlExpr
    """
    return func("json_serialize_plan", col0, col1, col2, col3, col4)


def json_serialize_sql(
    col0: SqlExpr | str,
    col1: SqlExpr | bool | None = None,
    col2: SqlExpr | bool | None = None,
    col3: SqlExpr | bool | None = None,
    col4: SqlExpr | bool | None = None,
) -> SqlExpr:
    """SQL json_serialize_sql function.

    Args:
        col0 (SqlExpr | str): `VARCHAR` expression
        col1 (SqlExpr | bool | None): `BOOLEAN` expression
        col2 (SqlExpr | bool | None): `BOOLEAN` expression
        col3 (SqlExpr | bool | None): `BOOLEAN` expression
        col4 (SqlExpr | bool | None): `BOOLEAN` expression

    Returns:
        SqlExpr
    """
    return func("json_serialize_sql", col0, col1, col2, col3, col4)


def json_structure(col0: SqlExpr | str) -> SqlExpr:
    """SQL json_structure function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("json_structure", col0)


def json_transform(col0: SqlExpr | str, col1: SqlExpr | str) -> SqlExpr:
    """SQL json_transform function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("json_transform", col0, col1)


def json_transform_strict(col0: SqlExpr | str, col1: SqlExpr | str) -> SqlExpr:
    """SQL json_transform_strict function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("json_transform_strict", col0, col1)


def json_type(
    col0: SqlExpr | str, col1: SqlExpr | list[str] | str | None = None
) -> SqlExpr:
    """SQL json_type function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | list[str] | str | None): `VARCHAR | VARCHAR[]` expression

    Returns:
        SqlExpr
    """
    return func("json_type", col0, col1)


def json_valid(col0: SqlExpr | str) -> SqlExpr:
    """SQL json_valid function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("json_valid", col0)


def json_value(col0: SqlExpr | str, col1: SqlExpr | int | list[str] | str) -> SqlExpr:
    """SQL json_value function.

    Args:
        col0 (SqlExpr | str): `JSON | VARCHAR` expression
        col1 (SqlExpr | int | list[str] | str): `BIGINT | VARCHAR | VARCHAR[]` expression

    Returns:
        SqlExpr
    """
    return func("json_value", col0, col1)


# ============================================================
# List
# ============================================================


def list_aggregate(
    list_arg: SqlExpr, function_name: SqlExpr | str, *args: SqlExpr
) -> SqlExpr:
    """Executes the aggregate function `function_name` on the elements of `list`.

    Args:
        list_arg (SqlExpr): `ANY[]` expression
        function_name (SqlExpr | str): `VARCHAR` expression
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_aggregate", list_arg, function_name, *args)


def list_any_value(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_any_value function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_any_value", l_arg)


def list_append(l_arg: SqlExpr, e: SqlExpr) -> SqlExpr:
    """SQL list_append function.

    Args:
        l_arg (SqlExpr): `ANY` expression
        e (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_append", l_arg, e)


def list_approx_count_distinct(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_approx_count_distinct function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_approx_count_distinct", l_arg)


def list_avg(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_avg function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_avg", l_arg)


def list_bit_and(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_bit_and function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_bit_and", l_arg)


def list_bit_or(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_bit_or function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_bit_or", l_arg)


def list_bit_xor(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_bit_xor function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_bit_xor", l_arg)


def list_bool_and(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_bool_and function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_bool_and", l_arg)


def list_bool_or(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_bool_or function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_bool_or", l_arg)


def list_concat(*args: SqlExpr) -> SqlExpr:
    """Concatenates lists.

    `NULL` inputs are skipped.

    See also operator `||`.

    Args:
        *args (SqlExpr): `ANY[]` expression

    Returns:
        SqlExpr
    """
    return func("list_concat", *args)


def list_contains(list_arg: SqlExpr, element: SqlExpr) -> SqlExpr:
    """Returns true if the list contains the element.

    Args:
        list_arg (SqlExpr): `T[]` expression
        element (SqlExpr): `T` expression

    Returns:
        SqlExpr
    """
    return func("list_contains", list_arg, element)


def list_cosine_distance(
    list1: SqlExpr | list[float], list2: SqlExpr | list[float]
) -> SqlExpr:
    """Computes the cosine distance between two same-sized lists.

    Args:
        list1 (SqlExpr | list[float]): `DOUBLE[] | FLOAT[]` expression
        list2 (SqlExpr | list[float]): `DOUBLE[] | FLOAT[]` expression

    Returns:
        SqlExpr
    """
    return func("list_cosine_distance", list1, list2)


def list_cosine_similarity(
    list1: SqlExpr | list[float], list2: SqlExpr | list[float]
) -> SqlExpr:
    """Computes the cosine similarity between two same-sized lists.

    Args:
        list1 (SqlExpr | list[float]): `DOUBLE[] | FLOAT[]` expression
        list2 (SqlExpr | list[float]): `DOUBLE[] | FLOAT[]` expression

    Returns:
        SqlExpr
    """
    return func("list_cosine_similarity", list1, list2)


def list_count(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_count function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_count", l_arg)


def list_distance(
    list1: SqlExpr | list[float], list2: SqlExpr | list[float]
) -> SqlExpr:
    """Calculates the Euclidean distance between two points with coordinates given in two inputs lists of equal length.

    Args:
        list1 (SqlExpr | list[float]): `DOUBLE[] | FLOAT[]` expression
        list2 (SqlExpr | list[float]): `DOUBLE[] | FLOAT[]` expression

    Returns:
        SqlExpr
    """
    return func("list_distance", list1, list2)


def list_distinct(list_arg: SqlExpr) -> SqlExpr:
    """Removes all duplicates and `NULL` values from a list.

    Does not preserve the original order.

    Args:
        list_arg (SqlExpr): `T[]` expression

    Returns:
        SqlExpr
    """
    return func("list_distinct", list_arg)


def list_entropy(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_entropy function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_entropy", l_arg)


def list_extract(list_arg: SqlExpr | str, index: SqlExpr | int) -> SqlExpr:
    """Extract the `index`th (1-based) value from the list.

    Args:
        list_arg (SqlExpr | SqlExpr | str): `T[] | VARCHAR` expression
        index (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("list_extract", list_arg, index)


def list_filter(list_arg: SqlExpr, lambda_arg: SqlExpr) -> SqlExpr:
    """Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`.

    DuckDB must be able to cast the `lambda` function's return type to `BOOL`.

    The return type of `list_filter` is the same as the input list's.

    Args:
        list_arg (SqlExpr): `ANY[]` expression
        lambda_arg (SqlExpr): `LAMBDA` expression

    Returns:
        SqlExpr
    """
    return func("list_filter", list_arg, lambda_arg)


def list_first(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_first function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_first", l_arg)


def list_fn(arg: SqlExpr) -> SqlExpr:
    """Returns a LIST containing all the values of a column.

    Args:
        arg (SqlExpr): `T` expression

    Returns:
        SqlExpr
    """
    return func("list", arg)


def list_grade_up(
    list_arg: SqlExpr,
    col1: SqlExpr | str | None = None,
    col2: SqlExpr | str | None = None,
) -> SqlExpr:
    """Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.

    Args:
        list_arg (SqlExpr): `ANY[]` expression
        col1 (SqlExpr | str | None): `VARCHAR` expression
        col2 (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("list_grade_up", list_arg, col1, col2)


def list_has_all(list1: SqlExpr, list2: SqlExpr) -> SqlExpr:
    """Returns true if all elements of list2 are in list1.

    NULLs are ignored.

    Args:
        list1 (SqlExpr): `T[]` expression
        list2 (SqlExpr): `T[]` expression

    Returns:
        SqlExpr
    """
    return func("list_has_all", list1, list2)


def list_has_any(list1: SqlExpr, list2: SqlExpr) -> SqlExpr:
    """Returns true if the lists have any element in common.

    NULLs are ignored.

    Args:
        list1 (SqlExpr): `T[]` expression
        list2 (SqlExpr): `T[]` expression

    Returns:
        SqlExpr
    """
    return func("list_has_any", list1, list2)


def list_histogram(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_histogram function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_histogram", l_arg)


def list_inner_product(
    list1: SqlExpr | list[float], list2: SqlExpr | list[float]
) -> SqlExpr:
    """Computes the inner product between two same-sized lists.

    Args:
        list1 (SqlExpr | list[float]): `DOUBLE[] | FLOAT[]` expression
        list2 (SqlExpr | list[float]): `DOUBLE[] | FLOAT[]` expression

    Returns:
        SqlExpr
    """
    return func("list_inner_product", list1, list2)


def list_intersect(l1: SqlExpr, l2: SqlExpr) -> SqlExpr:
    """SQL list_intersect function.

    Args:
        l1 (SqlExpr): `ANY` expression
        l2 (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_intersect", l1, l2)


def list_kurtosis(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_kurtosis function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_kurtosis", l_arg)


def list_kurtosis_pop(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_kurtosis_pop function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_kurtosis_pop", l_arg)


def list_last(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_last function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_last", l_arg)


def list_length(list_arg: SqlExpr) -> SqlExpr:
    """Returns the length of the `list`.

    Args:
        list_arg (SqlExpr): `ANY[]` expression

    Returns:
        SqlExpr
    """
    return func("length", list_arg)


def list_list_slice(
    list_arg: SqlExpr, begin: SqlExpr, end: SqlExpr, step: SqlExpr | int | None = None
) -> SqlExpr:
    """list_slice with added step feature.

    Args:
        list_arg (SqlExpr): `ANY` expression
        begin (SqlExpr): `ANY` expression
        end (SqlExpr): `ANY` expression
        step (SqlExpr | int | None): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("list_slice", list_arg, begin, end, step)


def list_mad(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_mad function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_mad", l_arg)


def list_max(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_max function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_max", l_arg)


def list_median(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_median function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_median", l_arg)


def list_min(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_min function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_min", l_arg)


def list_mode(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_mode function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_mode", l_arg)


def list_negative_inner_product(
    list1: SqlExpr | list[float], list2: SqlExpr | list[float]
) -> SqlExpr:
    """Computes the negative inner product between two same-sized lists.

    Args:
        list1 (SqlExpr | list[float]): `DOUBLE[] | FLOAT[]` expression
        list2 (SqlExpr | list[float]): `DOUBLE[] | FLOAT[]` expression

    Returns:
        SqlExpr
    """
    return func("list_negative_inner_product", list1, list2)


def list_position(list_arg: SqlExpr, element: SqlExpr) -> SqlExpr:
    """Returns the index of the `element` if the `list` contains the `element`.

    If the `element` is not found, it returns `NULL`.

    Args:
        list_arg (SqlExpr): `T[]` expression
        element (SqlExpr): `T` expression

    Returns:
        SqlExpr
    """
    return func("list_position", list_arg, element)


def list_prepend(e: SqlExpr, l_arg: SqlExpr) -> SqlExpr:
    """SQL list_prepend function.

    Args:
        e (SqlExpr): `ANY` expression
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_prepend", e, l_arg)


def list_product(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_product function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_product", l_arg)


def list_reduce(
    list_arg: SqlExpr, lambda_arg: SqlExpr, initial_value: SqlExpr | None = None
) -> SqlExpr:
    """Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element.

    The `lambda` function has an optional `initial_value` argument.

    Args:
        list_arg (SqlExpr): `ANY[]` expression
        lambda_arg (SqlExpr): `LAMBDA` expression
        initial_value (SqlExpr | None): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_reduce", list_arg, lambda_arg, initial_value)


def list_resize(
    list_arg: SqlExpr, size: SqlExpr, value: SqlExpr | None = None
) -> SqlExpr:
    """Resizes the `list` to contain `size` elements.

    Initializes new elements with `value` or `NULL` if `value` is not set.

    Args:
        list_arg (SqlExpr): `ANY[]` expression
        size (SqlExpr): `ANY` expression
        value (SqlExpr | None): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_resize", list_arg, size, value)


def list_reverse(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_reverse function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_reverse", l_arg)


def list_reverse_sort(list_arg: SqlExpr, col1: SqlExpr | str | None = None) -> SqlExpr:
    """Sorts the elements of the list in reverse order.

    Args:
        list_arg (SqlExpr): `ANY[]` expression
        col1 (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("list_reverse_sort", list_arg, col1)


def list_select(value_list: SqlExpr, index_list: SqlExpr | list[int]) -> SqlExpr:
    """Returns a list based on the elements selected by the `index_list`.

    Args:
        value_list (SqlExpr): `T[]` expression
        index_list (SqlExpr | list[int]): `BIGINT[]` expression

    Returns:
        SqlExpr
    """
    return func("list_select", value_list, index_list)


def list_sem(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_sem function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_sem", l_arg)


def list_skewness(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_skewness function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_skewness", l_arg)


def list_sort(
    list_arg: SqlExpr,
    col1: SqlExpr | str | None = None,
    col2: SqlExpr | str | None = None,
) -> SqlExpr:
    """Sorts the elements of the list.

    Args:
        list_arg (SqlExpr): `ANY[]` expression
        col1 (SqlExpr | str | None): `VARCHAR` expression
        col2 (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("list_sort", list_arg, col1, col2)


def list_stddev_pop(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_stddev_pop function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_stddev_pop", l_arg)


def list_stddev_samp(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_stddev_samp function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_stddev_samp", l_arg)


def list_string_agg(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_string_agg function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_string_agg", l_arg)


def list_string_list_slice(list_arg: SqlExpr, begin: SqlExpr, end: SqlExpr) -> SqlExpr:
    """Extracts a sublist or substring using slice conventions.

    Negative values are accepted.

    Args:
        list_arg (SqlExpr): `ANY` expression
        begin (SqlExpr): `ANY` expression
        end (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_slice", list_arg, begin, end)


def list_sum(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_sum function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_sum", l_arg)


def list_transform(list_arg: SqlExpr, lambda_arg: SqlExpr) -> SqlExpr:
    """Returns a list that is the result of applying the `lambda` function to each element of the input `list`.

    The return type is defined by the return type of the `lambda` function.

    Args:
        list_arg (SqlExpr): `ANY[]` expression
        lambda_arg (SqlExpr): `LAMBDA` expression

    Returns:
        SqlExpr
    """
    return func("list_transform", list_arg, lambda_arg)


def list_unique(list_arg: SqlExpr) -> SqlExpr:
    """Counts the unique elements of a `list`.

    Args:
        list_arg (SqlExpr): `ANY[]` expression

    Returns:
        SqlExpr
    """
    return func("list_unique", list_arg)


def list_value(any_arg: SqlExpr, *args: SqlExpr) -> SqlExpr:
    """Creates a LIST containing the argument values.

    Args:
        any_arg (SqlExpr): `T` expression
        *args (SqlExpr): `T` expression

    Returns:
        SqlExpr
    """
    return func("list_value", any_arg, *args)


def list_var_pop(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_var_pop function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_var_pop", l_arg)


def list_var_samp(l_arg: SqlExpr) -> SqlExpr:
    """SQL list_var_samp function.

    Args:
        l_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_var_samp", l_arg)


def list_where(value_list: SqlExpr, mask_list: SqlExpr | list[bool]) -> SqlExpr:
    """Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`.

    Args:
        value_list (SqlExpr): `T[]` expression
        mask_list (SqlExpr | list[bool]): `BOOLEAN[]` expression

    Returns:
        SqlExpr
    """
    return func("list_where", value_list, mask_list)


def list_zip(*args: SqlExpr) -> SqlExpr:
    """Zips n `LIST`s to a new `LIST` whose length will be that of the longest list.

    Its elements are structs of n elements from each list `list_1`, , `list_n`, missing elements are replaced with `NULL`.

    If `truncate` is set, all lists are truncated to the smallest list length.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("list_zip", *args)


# ============================================================
# Macro
# ============================================================


def col_description(table_oid: SqlExpr, column_number: SqlExpr) -> SqlExpr:
    """SQL col_description function.

    Args:
        table_oid (SqlExpr): `ANY` expression
        column_number (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("col_description", table_oid, column_number)


def fdiv(x: SqlExpr, y: SqlExpr) -> SqlExpr:
    """SQL fdiv function.

    Args:
        x (SqlExpr): `ANY` expression
        y (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("fdiv", x, y)


def fmod(x: SqlExpr, y: SqlExpr) -> SqlExpr:
    """SQL fmod function.

    Args:
        x (SqlExpr): `ANY` expression
        y (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("fmod", x, y)


def format_pg_type(logical_type: SqlExpr, type_name: SqlExpr) -> SqlExpr:
    """SQL format_pg_type function.

    Args:
        logical_type (SqlExpr): `ANY` expression
        type_name (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("format_pg_type", logical_type, type_name)


def format_type(type_oid: SqlExpr, typemod: SqlExpr) -> SqlExpr:
    """SQL format_type function.

    Args:
        type_oid (SqlExpr): `ANY` expression
        typemod (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("format_type", type_oid, typemod)


def generate_subscripts(arr: SqlExpr, dim: SqlExpr) -> SqlExpr:
    """SQL generate_subscripts function.

    Args:
        arr (SqlExpr): `ANY` expression
        dim (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("generate_subscripts", arr, dim)


def geomean(x: SqlExpr) -> SqlExpr:
    """SQL geomean function.

    Args:
        x (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("geomean", x)


def geometric_mean(x: SqlExpr) -> SqlExpr:
    """SQL geometric_mean function.

    Args:
        x (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("geometric_mean", x)


def get_block_size(db_name: SqlExpr) -> SqlExpr:
    """SQL get_block_size function.

    Args:
        db_name (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("get_block_size", db_name)


def md5_number_lower(param: SqlExpr) -> SqlExpr:
    """SQL md5_number_lower function.

    Args:
        param (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("md5_number_lower", param)


def md5_number_upper(param: SqlExpr) -> SqlExpr:
    """SQL md5_number_upper function.

    Args:
        param (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("md5_number_upper", param)


def nullif(a: SqlExpr, b: SqlExpr) -> SqlExpr:
    """SQL nullif function.

    Args:
        a (SqlExpr): `ANY` expression
        b (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("nullif", a, b)


def obj_description(object_oid: SqlExpr, catalog_name: SqlExpr) -> SqlExpr:
    """SQL obj_description function.

    Args:
        object_oid (SqlExpr): `ANY` expression
        catalog_name (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("obj_description", object_oid, catalog_name)


def round_even(x: SqlExpr, n: SqlExpr) -> SqlExpr:
    """SQL round_even function.

    Args:
        x (SqlExpr): `ANY` expression
        n (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("round_even", x, n)


def roundbankers(x: SqlExpr, n: SqlExpr) -> SqlExpr:
    """SQL roundbankers function.

    Args:
        x (SqlExpr): `ANY` expression
        n (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("roundbankers", x, n)


def shobj_description(object_oid: SqlExpr, catalog_name: SqlExpr) -> SqlExpr:
    """SQL shobj_description function.

    Args:
        object_oid (SqlExpr): `ANY` expression
        catalog_name (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("shobj_description", object_oid, catalog_name)


def split_part(string: SqlExpr, delimiter: SqlExpr, position: SqlExpr) -> SqlExpr:
    """SQL split_part function.

    Args:
        string (SqlExpr): `ANY` expression
        delimiter (SqlExpr): `ANY` expression
        position (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("split_part", string, delimiter, position)


def wavg(value: SqlExpr, weight: SqlExpr) -> SqlExpr:
    """SQL wavg function.

    Args:
        value (SqlExpr): `ANY` expression
        weight (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("wavg", value, weight)


def weighted_avg(value: SqlExpr, weight: SqlExpr) -> SqlExpr:
    """SQL weighted_avg function.

    Args:
        value (SqlExpr): `ANY` expression
        weight (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("weighted_avg", value, weight)


# ============================================================
# Map
# ============================================================


def map(keys: SqlExpr | list[SqlExpr], values: SqlExpr | list[SqlExpr]) -> SqlExpr:
    """Creates a map from a set of keys and values.

    Args:
        keys (SqlExpr | list[SqlExpr]): `K[]` expression
        values (SqlExpr | list[SqlExpr]): `V[]` expression

    Returns:
        SqlExpr
    """
    return func("map", keys, values)


def map_concat(*args: SqlExpr) -> SqlExpr:
    """Returns a map created from merging the input maps, on key collision the value is taken from the last map with that key.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("map_concat", *args)


def map_contains(map_arg: SqlExpr, key: SqlExpr) -> SqlExpr:
    """Checks if a map contains a given key.

    Args:
        map_arg (SqlExpr): `MAP(K, V)` expression
        key (SqlExpr): `K` expression

    Returns:
        SqlExpr
    """
    return func("map_contains", map_arg, key)


def map_contains_entry(map_arg: SqlExpr, key: SqlExpr, value: SqlExpr) -> SqlExpr:
    """SQL map_contains_entry function.

    Args:
        map_arg (SqlExpr): `ANY` expression
        key (SqlExpr): `ANY` expression
        value (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("map_contains_entry", map_arg, key, value)


def map_contains_value(map_arg: SqlExpr, value: SqlExpr) -> SqlExpr:
    """SQL map_contains_value function.

    Args:
        map_arg (SqlExpr): `ANY` expression
        value (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("map_contains_value", map_arg, value)


def map_entries(map_arg: SqlExpr) -> SqlExpr:
    """Returns the map entries as a list of keys/values.

    Args:
        map_arg (SqlExpr): `MAP(K, V)` expression

    Returns:
        SqlExpr
    """
    return func("map_entries", map_arg)


def map_extract(map_arg: SqlExpr, key: SqlExpr) -> SqlExpr:
    """Returns a list containing the value for a given key or an empty list if the key is not contained in the map.

    The type of the key provided in the second parameter must match the type of the map's keys else an error is returned.

    Args:
        map_arg (SqlExpr): `MAP(K, V)` expression
        key (SqlExpr): `K` expression

    Returns:
        SqlExpr
    """
    return func("map_extract", map_arg, key)


def map_extract_value(map_arg: SqlExpr, key: SqlExpr) -> SqlExpr:
    """Returns the value for a given key or NULL if the key is not contained in the map.

    The type of the key provided in the second parameter must match the type of the map's keys else an error is returned.

    Args:
        map_arg (SqlExpr): `MAP(K, V)` expression
        key (SqlExpr): `K` expression

    Returns:
        SqlExpr
    """
    return func("map_extract_value", map_arg, key)


def map_from_entries(map_arg: SqlExpr | list[SqlExpr]) -> SqlExpr:
    """Returns a map created from the entries of the array.

    Args:
        map_arg (SqlExpr | list[SqlExpr]): `STRUCT(K, V)[]` expression

    Returns:
        SqlExpr
    """
    return func("map_from_entries", map_arg)


def map_keys(map_arg: SqlExpr) -> SqlExpr:
    """Returns the keys of a map as a list.

    Args:
        map_arg (SqlExpr): `MAP(K, V)` expression

    Returns:
        SqlExpr
    """
    return func("map_keys", map_arg)


def map_to_pg_oid(type_name: SqlExpr) -> SqlExpr:
    """SQL map_to_pg_oid function.

    Args:
        type_name (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("map_to_pg_oid", type_name)


def map_values(map_arg: SqlExpr) -> SqlExpr:
    """Returns the values of a map as a list.

    Args:
        map_arg (SqlExpr): `MAP(K, V)` expression

    Returns:
        SqlExpr
    """
    return func("map_values", map_arg)


# ============================================================
# Regular Expression
# ============================================================


def regexp_escape(string: SqlExpr | str) -> SqlExpr:
    """Escapes special patterns to turn `string` into a regular expression similarly to Python's `re.escape` function.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("regexp_escape", string)


def regexp_extract(
    string: SqlExpr | str,
    regex: SqlExpr | str,
    group: SqlExpr | int | None = None,
    options: SqlExpr | str | None = None,
) -> SqlExpr:
    """If `string` contains the `regex` pattern, returns the capturing group specified by optional parameter `group`; otherwise, returns the empty string.

    The `group` must be a constant value.

    If no `group` is given, it defaults to 0.

    A set of optional regex `options` can be set.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        regex (SqlExpr | str): `VARCHAR` expression
        group (SqlExpr | int | None): `INTEGER` expression
        options (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("regexp_extract", string, regex, group, options)


def regexp_extract_all(
    string: SqlExpr | str,
    regex: SqlExpr | str,
    group: SqlExpr | int | None = None,
    options: SqlExpr | str | None = None,
) -> SqlExpr:
    """Finds non-overlapping occurrences of the `regex` in the `string` and returns the corresponding values of the capturing `group`.

    A set of optional regex `options` can be set.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        regex (SqlExpr | str): `VARCHAR` expression
        group (SqlExpr | int | None): `INTEGER` expression
        options (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("regexp_extract_all", string, regex, group, options)


def regexp_extract_name_list(
    string: SqlExpr | str,
    regex: SqlExpr | str,
    name_list: SqlExpr | list[str] | None = None,
    options: SqlExpr | str | None = None,
) -> SqlExpr:
    """If `string` contains the `regex` pattern, returns the capturing groups as a struct with corresponding names from `name_list`; otherwise, returns a struct with the same keys and empty strings as values.

    A set of optional regex `options` can be set.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        regex (SqlExpr | str): `VARCHAR` expression
        name_list (SqlExpr | list[str] | None): `VARCHAR[]` expression
        options (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("regexp_extract", string, regex, name_list, options)


def regexp_full_match(
    string: SqlExpr | str, regex: SqlExpr | str, col2: SqlExpr | str | None = None
) -> SqlExpr:
    """Returns `true` if the entire `string` matches the `regex`.

    A set of optional regex `options` can be set.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        regex (SqlExpr | str): `VARCHAR` expression
        col2 (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("regexp_full_match", string, regex, col2)


def regexp_matches(
    string: SqlExpr | str, regex: SqlExpr | str, options: SqlExpr | str | None = None
) -> SqlExpr:
    """Returns `true` if `string` contains the `regex`, `false` otherwise.

    A set of optional regex `options` can be set.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        regex (SqlExpr | str): `VARCHAR` expression
        options (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("regexp_matches", string, regex, options)


def regexp_replace(
    string: SqlExpr | str,
    regex: SqlExpr | str,
    replacement: SqlExpr | str,
    options: SqlExpr | str | None = None,
) -> SqlExpr:
    """If `string` contains the `regex`, replaces the matching part with `replacement`.

    A set of optional regex `options` can be set.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        regex (SqlExpr | str): `VARCHAR` expression
        replacement (SqlExpr | str): `VARCHAR` expression
        options (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("regexp_replace", string, regex, replacement, options)


def regexp_split_to_table(text: SqlExpr, pattern: SqlExpr) -> SqlExpr:
    """SQL regexp_split_to_table function.

    Args:
        text (SqlExpr): `ANY` expression
        pattern (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("regexp_split_to_table", text, pattern)


# ============================================================
# Scalar
# ============================================================


def abs(x: SqlExpr | Decimal | float) -> SqlExpr:
    """Absolute value.

    Args:
        x (SqlExpr | Decimal | float | int): `BIGINT | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

    Returns:
        SqlExpr
    """
    return func("abs", x)


def acos(x: SqlExpr | float) -> SqlExpr:
    """Computes the arccosine of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("acos", x)


def acosh(x: SqlExpr | float) -> SqlExpr:
    """Computes the inverse hyperbolic cos of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("acosh", x)


def add(
    col0: SqlExpr | Decimal | date | datetime | float | time | timedelta | None = None,
    col1: SqlExpr | Decimal | date | datetime | float | time | timedelta | None = None,
    *args: SqlExpr,
) -> SqlExpr:
    """SQL add function.

    Args:
        col0 (SqlExpr | Decimal | SqlExpr | date | datetime | float | int | time | timedelta | None): `BIGINT | BIGNUM | DATE | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | INTERVAL | SMALLINT | TIME | TIME WITH TIME ZONE | TIMESTAMP | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression
        col1 (SqlExpr | Decimal | SqlExpr | date | datetime | float | int | time | timedelta | None): `BIGINT | BIGNUM | DATE | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | INTERVAL | SMALLINT | TIME | TIME WITH TIME ZONE | TIMESTAMP | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression
        *args (SqlExpr): `ANY[]` expression

    Returns:
        SqlExpr
    """
    return func("add", col0, col1, *args)


def age(
    timestamp: SqlExpr | datetime, timestamp_3: SqlExpr | datetime | None = None
) -> SqlExpr:
    """Subtract arguments, resulting in the time difference between the two timestamps.

    Args:
        timestamp (SqlExpr | datetime): `TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
        timestamp_3 (SqlExpr | datetime | None): `TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("age", timestamp, timestamp_3)


def alias(expr: SqlExpr) -> SqlExpr:
    """Returns the name of a given expression.

    Args:
        expr (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("alias", expr)


def ascii(string: SqlExpr | str) -> SqlExpr:
    """Returns an integer that represents the Unicode code point of the first character of the `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("ascii", string)


def asin(x: SqlExpr | float) -> SqlExpr:
    """Computes the arcsine of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("asin", x)


def asinh(x: SqlExpr | float) -> SqlExpr:
    """Computes the inverse hyperbolic sin of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("asinh", x)


def atan(x: SqlExpr | float) -> SqlExpr:
    """Computes the arctangent of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("atan", x)


def atan2(y: SqlExpr | float, x: SqlExpr | float) -> SqlExpr:
    """Computes the arctangent (y, x).

    Args:
        y (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("atan2", y, x)


def atanh(x: SqlExpr | float) -> SqlExpr:
    """Computes the inverse hyperbolic tan of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("atanh", x)


def bar(
    x: SqlExpr | float,
    min_arg: SqlExpr | float,
    max_arg: SqlExpr | float,
    width: SqlExpr | float | None = None,
) -> SqlExpr:
    """Draws a band whose width is proportional to (`x - min`) and equal to `width` characters when `x` = `max`.

    `width` defaults to 80.

    Args:
        x (SqlExpr | float): `DOUBLE` expression
        min_arg (SqlExpr | float): `DOUBLE` expression
        max_arg (SqlExpr | float): `DOUBLE` expression
        width (SqlExpr | float | None): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("bar", x, min_arg, max_arg, width)


def blob_hex(blob: SqlExpr | bytes | bytearray | memoryview) -> SqlExpr:
    """Converts `blob` to `VARCHAR` using hexadecimal encoding.

    Args:
        blob (SqlExpr | bytes | bytearray | memoryview): `BLOB` expression

    Returns:
        SqlExpr
    """
    return func("hex", blob)


def blob_md5(blob: SqlExpr | bytes | bytearray | memoryview) -> SqlExpr:
    """Returns the MD5 hash of the `blob` as a `VARCHAR`.

    Args:
        blob (SqlExpr | bytes | bytearray | memoryview): `BLOB` expression

    Returns:
        SqlExpr
    """
    return func("md5", blob)


def blob_md5_number(blob: SqlExpr | bytes | bytearray | memoryview) -> SqlExpr:
    """Returns the MD5 hash of the `blob` as a `HUGEINT`.

    Args:
        blob (SqlExpr | bytes | bytearray | memoryview): `BLOB` expression

    Returns:
        SqlExpr
    """
    return func("md5_number", blob)


def blob_octet_length(blob: SqlExpr | bytes | bytearray | memoryview) -> SqlExpr:
    """Number of bytes in `blob`.

    Args:
        blob (SqlExpr | bytes | bytearray | memoryview): `BLOB` expression

    Returns:
        SqlExpr
    """
    return func("octet_length", blob)


def blob_repeat(
    blob: SqlExpr | bytes | bytearray | memoryview, count: SqlExpr | int
) -> SqlExpr:
    """Repeats the `blob` `count` number of times.

    Args:
        blob (SqlExpr | bytes | bytearray | memoryview): `BLOB` expression
        count (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("repeat", blob, count)


def blob_sha1(blob: SqlExpr | bytes | bytearray | memoryview) -> SqlExpr:
    """Returns a `VARCHAR` with the SHA-1 hash of the `blob`.

    Args:
        blob (SqlExpr | bytes | bytearray | memoryview): `BLOB` expression

    Returns:
        SqlExpr
    """
    return func("sha1", blob)


def blob_sha256(blob: SqlExpr | bytes | bytearray | memoryview) -> SqlExpr:
    """Returns a `VARCHAR` with the SHA-256 hash of the `blob`.

    Args:
        blob (SqlExpr | bytes | bytearray | memoryview): `BLOB` expression

    Returns:
        SqlExpr
    """
    return func("sha256", blob)


def can_cast_implicitly(source_type: SqlExpr, target_type: SqlExpr) -> SqlExpr:
    """Whether or not we can implicitly cast from the source type to the other type.

    Args:
        source_type (SqlExpr): `ANY` expression
        target_type (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("can_cast_implicitly", source_type, target_type)


def cardinality(map_arg: SqlExpr, *args: SqlExpr) -> SqlExpr:
    """Returns the size of the map (or the number of entries in the map).

    Args:
        map_arg (SqlExpr): `ANY` expression
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("cardinality", map_arg, *args)


def cast_to_type(param: SqlExpr, type_arg: SqlExpr) -> SqlExpr:
    """Casts the first argument to the type of the second argument.

    Args:
        param (SqlExpr): `ANY` expression
        type_arg (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("cast_to_type", param, type_arg)


def cbrt(x: SqlExpr | float) -> SqlExpr:
    """Returns the cube root of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("cbrt", x)


def ceil(x: SqlExpr | Decimal | float) -> SqlExpr:
    """Rounds the number up.

    Args:
        x (SqlExpr | Decimal | float): `DECIMAL | DOUBLE | FLOAT` expression

    Returns:
        SqlExpr
    """
    return func("ceil", x)


def century(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the century component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("century", ts)


def chr(code_point: SqlExpr | int) -> SqlExpr:
    """Returns a character which is corresponding the ASCII code value or Unicode code point.

    Args:
        code_point (SqlExpr | int): `INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("chr", code_point)


def combine(col0: SqlExpr, col1: SqlExpr) -> SqlExpr:
    """SQL combine function.

    Args:
        col0 (SqlExpr): `AGGREGATE_STATE<?>` expression
        col1 (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("combine", col0, col1)


def concat(value: SqlExpr, *args: SqlExpr) -> SqlExpr:
    """Concatenates multiple strings or lists.

    `NULL` inputs are skipped.

    See also operator `||`.

    Args:
        value (SqlExpr): `ANY` expression
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("concat", value, *args)


def concat_ws(separator: SqlExpr | str, string: SqlExpr, *args: SqlExpr) -> SqlExpr:
    """Concatenates many strings, separated by `separator`.

    `NULL` inputs are skipped.

    Args:
        separator (SqlExpr | str): `VARCHAR` expression
        string (SqlExpr): `ANY` expression
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("concat_ws", separator, string, *args)


def constant_or_null(arg1: SqlExpr, arg2: SqlExpr, *args: SqlExpr) -> SqlExpr:
    """If arg2 is NULL, return NULL.

    Otherwise, return arg1.

    Args:
        arg1 (SqlExpr): `ANY` expression
        arg2 (SqlExpr): `ANY` expression
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("constant_or_null", arg1, arg2, *args)


def contains(col0: SqlExpr | dict[object, object], col1: SqlExpr) -> SqlExpr:
    """SQL contains function.

    Args:
        col0 (SqlExpr | SqlExpr | dict[object, object]): `MAP(K, V) | STRUCT | T[]` expression
        col1 (SqlExpr): `ANY | K | T` expression

    Returns:
        SqlExpr
    """
    return func("contains", col0, col1)


def cos(x: SqlExpr | float) -> SqlExpr:
    """Computes the cos of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("cos", x)


def cosh(x: SqlExpr | float) -> SqlExpr:
    """Computes the hyperbolic cos of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("cosh", x)


def cot(x: SqlExpr | float) -> SqlExpr:
    """Computes the cotangent of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("cot", x)


def create_sort_key(parameters: SqlExpr, *args: SqlExpr) -> SqlExpr:
    """Constructs a binary-comparable sort key based on a set of input parameters and sort qualifiers.

    Args:
        parameters (SqlExpr): `ANY` expression
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("create_sort_key", parameters, *args)


def currval(sequence_name: SqlExpr | str) -> SqlExpr:
    """Return the current value of the sequence.

    Note that nextval must be called at least once prior to calling currval.

    Args:
        sequence_name (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("currval", sequence_name)


def damerau_levenshtein(s1: SqlExpr | str, s2: SqlExpr | str) -> SqlExpr:
    """Extension of Levenshtein distance to also include transposition of adjacent characters as an allowed edit operation.

    In other words, the minimum number of edit operations (insertions, deletions, substitutions or transpositions) required to change one string to another.

    Characters of different cases (e.g., `a` and `A`) are considered different.

    Args:
        s1 (SqlExpr | str): `VARCHAR` expression
        s2 (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("damerau_levenshtein", s1, s2)


def day(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the day component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("day", ts)


def dayname(ts: SqlExpr | date | datetime) -> SqlExpr:
    """The (English) name of the weekday.

    Args:
        ts (SqlExpr | date | datetime): `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("dayname", ts)


def dayofmonth(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the dayofmonth component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("dayofmonth", ts)


def dayofweek(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the dayofweek component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("dayofweek", ts)


def dayofyear(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the dayofyear component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("dayofyear", ts)


def decade(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the decade component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("decade", ts)


def decode(blob: SqlExpr | bytes | bytearray | memoryview) -> SqlExpr:
    """Converts `blob` to `VARCHAR`.

    Fails if `blob` is not valid UTF-8.

    Args:
        blob (SqlExpr | bytes | bytearray | memoryview): `BLOB` expression

    Returns:
        SqlExpr
    """
    return func("decode", blob)


def degrees(x: SqlExpr | float) -> SqlExpr:
    """Converts radians to degrees.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("degrees", x)


def divide(col0: SqlExpr | float, col1: SqlExpr | float) -> SqlExpr:
    """SQL divide function.

    Args:
        col0 (SqlExpr | float | int): `BIGINT | DOUBLE | FLOAT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression
        col1 (SqlExpr | float | int): `BIGINT | DOUBLE | FLOAT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

    Returns:
        SqlExpr
    """
    return func("divide", col0, col1)


def encode(string: SqlExpr | str) -> SqlExpr:
    """Converts the `string` to `BLOB`.

    Converts UTF-8 characters into literal encoding.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("encode", string)


def epoch(temporal: SqlExpr | date | datetime | time | timedelta) -> SqlExpr:
    """Extract the epoch component from a temporal type.

    Args:
        temporal (SqlExpr | date | datetime | time | timedelta): `DATE | INTERVAL | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME_NS` expression

    Returns:
        SqlExpr
    """
    return func("epoch", temporal)


def epoch_ms(temporal: SqlExpr | date | datetime | int | time | timedelta) -> SqlExpr:
    """Extract the epoch component in milliseconds from a temporal type.

    Args:
        temporal (SqlExpr | date | datetime | int | time | timedelta): `BIGINT | DATE | INTERVAL | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME_NS` expression

    Returns:
        SqlExpr
    """
    return func("epoch_ms", temporal)


def epoch_ns(temporal: SqlExpr | date | datetime | time | timedelta) -> SqlExpr:
    """Extract the epoch component in nanoseconds from a temporal type.

    Args:
        temporal (SqlExpr | date | datetime | time | timedelta): `DATE | INTERVAL | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIMESTAMP_NS | TIME_NS` expression

    Returns:
        SqlExpr
    """
    return func("epoch_ns", temporal)


def epoch_us(temporal: SqlExpr | date | datetime | time | timedelta) -> SqlExpr:
    """Extract the epoch component in microseconds from a temporal type.

    Args:
        temporal (SqlExpr | date | datetime | time | timedelta): `DATE | INTERVAL | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME_NS` expression

    Returns:
        SqlExpr
    """
    return func("epoch_us", temporal)


def equi_width_bins(
    min_arg: SqlExpr | datetime | float,
    max_arg: SqlExpr | datetime | float,
    bin_count: SqlExpr | int,
    nice_rounding: SqlExpr | bool,
) -> SqlExpr:
    """Generates bin_count equi-width bins between the min and max.

    If enabled nice_rounding makes the numbers more readable/less jagged.

    Args:
        min_arg (SqlExpr | SqlExpr | datetime | float | int): `ANY | BIGINT | DOUBLE | TIMESTAMP` expression
        max_arg (SqlExpr | SqlExpr | datetime | float | int): `ANY | BIGINT | DOUBLE | TIMESTAMP` expression
        bin_count (SqlExpr | int): `BIGINT` expression
        nice_rounding (SqlExpr | bool): `BOOLEAN` expression

    Returns:
        SqlExpr
    """
    return func("equi_width_bins", min_arg, max_arg, bin_count, nice_rounding)


def era(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the era component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("era", ts)


def error(message: SqlExpr | str) -> SqlExpr:
    """Throws the given error message.

    Args:
        message (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("error", message)


def even(x: SqlExpr | float) -> SqlExpr:
    """Rounds x to next even number by rounding away from zero.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("even", x)


def exp(x: SqlExpr | float) -> SqlExpr:
    """Computes e to the power of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("exp", x)


def factorial(x: SqlExpr | int) -> SqlExpr:
    """Factorial of x.

    Computes the product of the current integer and all integers below it.

    Args:
        x (SqlExpr | int): `INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("factorial", x)


def finalize(col0: SqlExpr) -> SqlExpr:
    """SQL finalize function.

    Args:
        col0 (SqlExpr): `AGGREGATE_STATE<?>` expression

    Returns:
        SqlExpr
    """
    return func("finalize", col0)


def flatten(nested_list: SqlExpr | list[SqlExpr]) -> SqlExpr:
    """Flattens a nested list by one level.

    Args:
        nested_list (SqlExpr | list[SqlExpr]): `T[][]` expression

    Returns:
        SqlExpr
    """
    return func("flatten", nested_list)


def floor(x: SqlExpr | Decimal | float) -> SqlExpr:
    """Rounds the number down.

    Args:
        x (SqlExpr | Decimal | float): `DECIMAL | DOUBLE | FLOAT` expression

    Returns:
        SqlExpr
    """
    return func("floor", x)


def format(format_arg: SqlExpr | str, *args: SqlExpr) -> SqlExpr:
    """Formats a string using the fmt syntax.

    Args:
        format_arg (SqlExpr | str): `VARCHAR` expression
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("format", format_arg, *args)


def format_bytes(integer: SqlExpr | int) -> SqlExpr:
    """Converts `integer` to a human-readable representation using units based on powers of 2 (KiB, MiB, GiB, etc.).

    Args:
        integer (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("format_bytes", integer)


def formatreadabledecimalsize(integer: SqlExpr | int) -> SqlExpr:
    """Converts `integer` to a human-readable representation using units based on powers of 10 (KB, MB, GB, etc.).

    Args:
        integer (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("formatReadableDecimalSize", integer)


def gamma(x: SqlExpr | float) -> SqlExpr:
    """Interpolation of (x-1) factorial (so decimal inputs are allowed).

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("gamma", x)


def generate_series(
    start: SqlExpr | datetime | int,
    stop: SqlExpr | datetime | int | None = None,
    step: SqlExpr | int | timedelta | None = None,
) -> SqlExpr:
    """Creates a list of values between `start` and `stop` - the stop parameter is inclusive.

    Args:
        start (SqlExpr | datetime | int): `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
        stop (SqlExpr | datetime | int | None): `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
        step (SqlExpr | int | timedelta | None): `BIGINT | INTERVAL` expression

    Returns:
        SqlExpr
    """
    return func("generate_series", start, stop, step)


def get_bit(
    bitstring: SqlExpr | bytes | bytearray | memoryview, index: SqlExpr | int
) -> SqlExpr:
    """Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0.

    Args:
        bitstring (SqlExpr | bytes | bytearray | memoryview): `BIT` expression
        index (SqlExpr | int): `INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("get_bit", bitstring, index)


def getvariable(col0: SqlExpr | str) -> SqlExpr:
    """SQL getvariable function.

    Args:
        col0 (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("getvariable", col0)


def greatest(arg1: SqlExpr, *args: SqlExpr) -> SqlExpr:
    """Returns the largest value.

    For strings lexicographical ordering is used.

    Note that lowercase characters are considered larger than uppercase characters and collations are not supported.

    Args:
        arg1 (SqlExpr): `ANY` expression
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("greatest", arg1, *args)


def greatest_common_divisor(x: SqlExpr | int, y: SqlExpr | int) -> SqlExpr:
    """Computes the greatest common divisor of x and y.

    Args:
        x (SqlExpr | int): `BIGINT | HUGEINT` expression
        y (SqlExpr | int): `BIGINT | HUGEINT` expression

    Returns:
        SqlExpr
    """
    return func("greatest_common_divisor", x, y)


def hamming(s1: SqlExpr | str, s2: SqlExpr | str) -> SqlExpr:
    """The Hamming distance between to strings, i.e., the number of positions with different characters for two strings of equal length.

    Strings must be of equal length.

    Characters of different cases (e.g., `a` and `A`) are considered different.

    Args:
        s1 (SqlExpr | str): `VARCHAR` expression
        s2 (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("hamming", s1, s2)


def hash(value: SqlExpr, *args: SqlExpr) -> SqlExpr:
    """Returns a `UBIGINT` with the hash of the `value`.

    Note that this is not a cryptographic hash.

    Args:
        value (SqlExpr): `ANY` expression
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("hash", value, *args)


def hour(ts: SqlExpr | date | datetime | time | timedelta) -> SqlExpr:
    """Extract the hour component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | time | timedelta): `DATE | INTERVAL | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME_NS` expression

    Returns:
        SqlExpr
    """
    return func("hour", ts)


def ilike_escape(
    string: SqlExpr | str,
    like_specifier: SqlExpr | str,
    escape_character: SqlExpr | str,
) -> SqlExpr:
    """Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching.

    `escape_character` is used to search for wildcard characters in the `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        like_specifier (SqlExpr | str): `VARCHAR` expression
        escape_character (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("ilike_escape", string, like_specifier, escape_character)


def in_search_path(database_name: SqlExpr | str, schema_name: SqlExpr | str) -> SqlExpr:
    """Returns whether or not the database/schema are in the search path.

    Args:
        database_name (SqlExpr | str): `VARCHAR` expression
        schema_name (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("in_search_path", database_name, schema_name)


def instr(string: SqlExpr | str, search_string: SqlExpr | str) -> SqlExpr:
    """Returns location of first occurrence of `search_string` in `string`, counting from 1.

    Returns 0 if no match found.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        search_string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("instr", string, search_string)


def is_histogram_other_bin(val: SqlExpr) -> SqlExpr:
    """Whether or not the provided value is the histogram "other" bin (used for values not belonging to any provided bin).

    Args:
        val (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("is_histogram_other_bin", val)


def isfinite(x: SqlExpr | date | datetime | float) -> SqlExpr:
    """Returns true if the floating point value is finite, false otherwise.

    Args:
        x (SqlExpr | date | datetime | float): `DATE | DOUBLE | FLOAT | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("isfinite", x)


def isinf(x: SqlExpr | date | datetime | float) -> SqlExpr:
    """Returns true if the floating point value is infinite, false otherwise.

    Args:
        x (SqlExpr | date | datetime | float): `DATE | DOUBLE | FLOAT | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("isinf", x)


def isnan(x: SqlExpr | float) -> SqlExpr:
    """Returns true if the floating point value is not a number, false otherwise.

    Args:
        x (SqlExpr | float): `DOUBLE | FLOAT` expression

    Returns:
        SqlExpr
    """
    return func("isnan", x)


def isodow(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the isodow component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("isodow", ts)


def isoyear(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the isoyear component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("isoyear", ts)


def jaccard(s1: SqlExpr | str, s2: SqlExpr | str) -> SqlExpr:
    """The Jaccard similarity between two strings.

    Characters of different cases (e.g., `a` and `A`) are considered different.

    Returns a number between 0 and 1.

    Args:
        s1 (SqlExpr | str): `VARCHAR` expression
        s2 (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("jaccard", s1, s2)


def jaro_similarity(
    s1: SqlExpr | str, s2: SqlExpr | str, score_cutoff: SqlExpr | float | None = None
) -> SqlExpr:
    """The Jaro similarity between two strings.

    Characters of different cases (e.g., `a` and `A`) are considered different.

    Returns a number between 0 and 1.

    For similarity < `score_cutoff`, 0 is returned instead.

    `score_cutoff` defaults to 0.

    Args:
        s1 (SqlExpr | str): `VARCHAR` expression
        s2 (SqlExpr | str): `VARCHAR` expression
        score_cutoff (SqlExpr | float | None): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("jaro_similarity", s1, s2, score_cutoff)


def jaro_winkler_similarity(
    s1: SqlExpr | str, s2: SqlExpr | str, score_cutoff: SqlExpr | float | None = None
) -> SqlExpr:
    """The Jaro-Winkler similarity between two strings.

    Characters of different cases (e.g., `a` and `A`) are considered different.

    Returns a number between 0 and 1.

    For similarity < `score_cutoff`, 0 is returned instead.

    `score_cutoff` defaults to 0.

    Args:
        s1 (SqlExpr | str): `VARCHAR` expression
        s2 (SqlExpr | str): `VARCHAR` expression
        score_cutoff (SqlExpr | float | None): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("jaro_winkler_similarity", s1, s2, score_cutoff)


def julian(ts: SqlExpr | date | datetime) -> SqlExpr:
    """Extract the Julian Day number from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime): `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("julian", ts)


def last_day(ts: SqlExpr | date | datetime) -> SqlExpr:
    """Returns the last day of the month.

    Args:
        ts (SqlExpr | date | datetime): `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("last_day", ts)


def least(arg1: SqlExpr, *args: SqlExpr) -> SqlExpr:
    """Returns the smallest value.

    For strings lexicographical ordering is used.

    Note that uppercase characters are considered smaller than lowercase characters, and collations are not supported.

    Args:
        arg1 (SqlExpr): `ANY` expression
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("least", arg1, *args)


def least_common_multiple(x: SqlExpr | int, y: SqlExpr | int) -> SqlExpr:
    """Computes the least common multiple of x and y.

    Args:
        x (SqlExpr | int): `BIGINT | HUGEINT` expression
        y (SqlExpr | int): `BIGINT | HUGEINT` expression

    Returns:
        SqlExpr
    """
    return func("least_common_multiple", x, y)


def left(string: SqlExpr | str, count: SqlExpr | int) -> SqlExpr:
    """Extracts the left-most count characters.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        count (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("left", string, count)


def left_grapheme(string: SqlExpr | str, count: SqlExpr | int) -> SqlExpr:
    """Extracts the left-most count grapheme clusters.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        count (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("left_grapheme", string, count)


def length_grapheme(string: SqlExpr | str) -> SqlExpr:
    """Number of grapheme clusters in `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("length_grapheme", string)


def levenshtein(s1: SqlExpr | str, s2: SqlExpr | str) -> SqlExpr:
    """The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other.

    Characters of different cases (e.g., `a` and `A`) are considered different.

    Args:
        s1 (SqlExpr | str): `VARCHAR` expression
        s2 (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("levenshtein", s1, s2)


def lgamma(x: SqlExpr | float) -> SqlExpr:
    """Computes the log of the gamma function.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("lgamma", x)


def like_escape(
    string: SqlExpr | str,
    like_specifier: SqlExpr | str,
    escape_character: SqlExpr | str,
) -> SqlExpr:
    """Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching.

    `escape_character` is used to search for wildcard characters in the `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        like_specifier (SqlExpr | str): `VARCHAR` expression
        escape_character (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("like_escape", string, like_specifier, escape_character)


def ln(x: SqlExpr | float) -> SqlExpr:
    """Computes the natural logarithm of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("ln", x)


def log(b: SqlExpr | float, x: SqlExpr | float | None = None) -> SqlExpr:
    """Computes the logarithm of x to base b.

    b may be omitted, in which case the default 10.

    Args:
        b (SqlExpr | float): `DOUBLE` expression
        x (SqlExpr | float | None): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("log", b, x)


def log10(x: SqlExpr | float) -> SqlExpr:
    """Computes the 10-log of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("log10", x)


def log2(x: SqlExpr | float) -> SqlExpr:
    """Computes the 2-log of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("log2", x)


def lower(string: SqlExpr | str) -> SqlExpr:
    """Converts `string` to lower case.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("lower", string)


def lpad(
    string: SqlExpr | str, count: SqlExpr | int, character: SqlExpr | str
) -> SqlExpr:
    """Pads the `string` with the `character` on the left until it has `count` characters.

    Truncates the `string` on the right if it has more than `count` characters.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        count (SqlExpr | int): `INTEGER` expression
        character (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("lpad", string, count, character)


def ltrim(string: SqlExpr | str, characters: SqlExpr | str | None = None) -> SqlExpr:
    """Removes any occurrences of any of the `characters` from the left side of the `string`.

    `characters` defaults to `space`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        characters (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("ltrim", string, characters)


def make_date(col0: SqlExpr | dict[object, object] | int) -> SqlExpr:
    """The date for the given struct.

    Args:
        col0 (SqlExpr | dict[object, object] | int): `INTEGER | STRUCT("year" BIGINT, "month" BIGINT, "day" BIGINT)` expression

    Returns:
        SqlExpr
    """
    return func("make_date", col0)


def make_date_month_day(
    year: SqlExpr | int,
    month: SqlExpr | int | None = None,
    day: SqlExpr | int | None = None,
) -> SqlExpr:
    """The date for the given parts.

    Args:
        year (SqlExpr | int): `BIGINT` expression
        month (SqlExpr | int | None): `BIGINT` expression
        day (SqlExpr | int | None): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("make_date", year, month, day)


def make_time(
    hour: SqlExpr | int, minute: SqlExpr | int, seconds: SqlExpr | float
) -> SqlExpr:
    """The time for the given parts.

    Args:
        hour (SqlExpr | int): `BIGINT` expression
        minute (SqlExpr | int): `BIGINT` expression
        seconds (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("make_time", hour, minute, seconds)


def make_timestamp(
    year: SqlExpr | int,
    month: SqlExpr | int | None = None,
    day: SqlExpr | int | None = None,
    hour: SqlExpr | int | None = None,
    minute: SqlExpr | int | None = None,
    seconds: SqlExpr | float | None = None,
) -> SqlExpr:
    """The timestamp for the given parts.

    Args:
        year (SqlExpr | int): `BIGINT` expression
        month (SqlExpr | int | None): `BIGINT` expression
        day (SqlExpr | int | None): `BIGINT` expression
        hour (SqlExpr | int | None): `BIGINT` expression
        minute (SqlExpr | int | None): `BIGINT` expression
        seconds (SqlExpr | float | None): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("make_timestamp", year, month, day, hour, minute, seconds)


def make_timestamp_ms(nanos: SqlExpr | int) -> SqlExpr:
    """The timestamp for the given microseconds since the epoch.

    Args:
        nanos (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("make_timestamp_ms", nanos)


def make_timestamp_ns(nanos: SqlExpr | int) -> SqlExpr:
    """The timestamp for the given nanoseconds since epoch.

    Args:
        nanos (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("make_timestamp_ns", nanos)


def make_timestamptz(
    col0: SqlExpr | int,
    col1: SqlExpr | int | None = None,
    col2: SqlExpr | int | None = None,
    col3: SqlExpr | int | None = None,
    col4: SqlExpr | int | None = None,
    col5: SqlExpr | float | None = None,
    col6: SqlExpr | str | None = None,
) -> SqlExpr:
    """SQL make_timestamptz function.

    Args:
        col0 (SqlExpr | int): `BIGINT` expression
        col1 (SqlExpr | int | None): `BIGINT` expression
        col2 (SqlExpr | int | None): `BIGINT` expression
        col3 (SqlExpr | int | None): `BIGINT` expression
        col4 (SqlExpr | int | None): `BIGINT` expression
        col5 (SqlExpr | float | None): `DOUBLE` expression
        col6 (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("make_timestamptz", col0, col1, col2, col3, col4, col5, col6)


def microsecond(ts: SqlExpr | date | datetime | time | timedelta) -> SqlExpr:
    """Extract the microsecond component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | time | timedelta): `DATE | INTERVAL | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME_NS` expression

    Returns:
        SqlExpr
    """
    return func("microsecond", ts)


def millennium(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the millennium component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("millennium", ts)


def millisecond(ts: SqlExpr | date | datetime | time | timedelta) -> SqlExpr:
    """Extract the millisecond component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | time | timedelta): `DATE | INTERVAL | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME_NS` expression

    Returns:
        SqlExpr
    """
    return func("millisecond", ts)


def minute(ts: SqlExpr | date | datetime | time | timedelta) -> SqlExpr:
    """Extract the minute component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | time | timedelta): `DATE | INTERVAL | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME_NS` expression

    Returns:
        SqlExpr
    """
    return func("minute", ts)


def mod(col0: SqlExpr | Decimal | float, col1: SqlExpr | Decimal | float) -> SqlExpr:
    """SQL mod function.

    Args:
        col0 (SqlExpr | Decimal | float | int): `BIGINT | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression
        col1 (SqlExpr | Decimal | float | int): `BIGINT | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

    Returns:
        SqlExpr
    """
    return func("mod", col0, col1)


def month(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the month component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("month", ts)


def monthname(ts: SqlExpr | date | datetime) -> SqlExpr:
    """The (English) name of the month.

    Args:
        ts (SqlExpr | date | datetime): `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("monthname", ts)


def multiply(
    col0: SqlExpr | Decimal | float | timedelta,
    col1: SqlExpr | Decimal | float | timedelta,
) -> SqlExpr:
    """SQL multiply function.

    Args:
        col0 (SqlExpr | Decimal | float | int | timedelta): `BIGINT | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | INTERVAL | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression
        col1 (SqlExpr | Decimal | float | int | timedelta): `BIGINT | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | INTERVAL | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

    Returns:
        SqlExpr
    """
    return func("multiply", col0, col1)


def nanosecond(tsns: SqlExpr | date | datetime | time | timedelta) -> SqlExpr:
    """Extract the nanosecond component from a date or timestamp.

    Args:
        tsns (SqlExpr | date | datetime | time | timedelta): `DATE | INTERVAL | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIMESTAMP_NS | TIME_NS` expression

    Returns:
        SqlExpr
    """
    return func("nanosecond", tsns)


def nextafter(x: SqlExpr | float, y: SqlExpr | float) -> SqlExpr:
    """Returns the next floating point value after x in the direction of y.

    Args:
        x (SqlExpr | float): `DOUBLE | FLOAT` expression
        y (SqlExpr | float): `DOUBLE | FLOAT` expression

    Returns:
        SqlExpr
    """
    return func("nextafter", x, y)


def nextval(sequence_name: SqlExpr | str) -> SqlExpr:
    """Return the following value of the sequence.

    Args:
        sequence_name (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("nextval", sequence_name)


def nfc_normalize(string: SqlExpr | str) -> SqlExpr:
    """Converts `string` to Unicode NFC normalized string.

    Useful for comparisons and ordering if text data is mixed between NFC normalized and not.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("nfc_normalize", string)


def normalized_interval(interval: SqlExpr | timedelta) -> SqlExpr:
    """Normalizes an INTERVAL to an equivalent interval.

    Args:
        interval (SqlExpr | timedelta): `INTERVAL` expression

    Returns:
        SqlExpr
    """
    return func("normalized_interval", interval)


def not_ilike_escape(
    string: SqlExpr | str,
    like_specifier: SqlExpr | str,
    escape_character: SqlExpr | str,
) -> SqlExpr:
    """Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching.

    `escape_character` is used to search for wildcard characters in the `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        like_specifier (SqlExpr | str): `VARCHAR` expression
        escape_character (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("not_ilike_escape", string, like_specifier, escape_character)


def not_like_escape(
    string: SqlExpr | str,
    like_specifier: SqlExpr | str,
    escape_character: SqlExpr | str,
) -> SqlExpr:
    """Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching.

    `escape_character` is used to search for wildcard characters in the `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        like_specifier (SqlExpr | str): `VARCHAR` expression
        escape_character (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("not_like_escape", string, like_specifier, escape_character)


def numeric_bin(value: SqlExpr | int) -> SqlExpr:
    """Converts the `value` to binary representation.

    Args:
        value (SqlExpr | SqlExpr | int): `BIGINT | BIGNUM | HUGEINT | UBIGINT | UHUGEINT` expression

    Returns:
        SqlExpr
    """
    return func("bin", value)


def numeric_bit_length(bit: SqlExpr | bytes | bytearray | memoryview) -> SqlExpr:
    """Returns the bit-length of the `bit` argument.

    Args:
        bit (SqlExpr | bytes | bytearray | memoryview): `BIT` expression

    Returns:
        SqlExpr
    """
    return func("bit_length", bit)


def numeric_hex(value: SqlExpr | int) -> SqlExpr:
    """Converts the `value` to `VARCHAR` using hexadecimal representation.

    Args:
        value (SqlExpr | SqlExpr | int): `BIGINT | BIGNUM | HUGEINT | UBIGINT | UHUGEINT` expression

    Returns:
        SqlExpr
    """
    return func("hex", value)


def numeric_length(bit: SqlExpr | bytes | bytearray | memoryview) -> SqlExpr:
    """Returns the bit-length of the `bit` argument.

    Args:
        bit (SqlExpr | bytes | bytearray | memoryview): `BIT` expression

    Returns:
        SqlExpr
    """
    return func("length", bit)


def parse_dirname(
    path: SqlExpr | str, separator: SqlExpr | str | None = None
) -> SqlExpr:
    """Returns the top-level directory name from the given `path`.

    `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.

    Args:
        path (SqlExpr | str): `VARCHAR` expression
        separator (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("parse_dirname", path, separator)


def parse_dirpath(
    path: SqlExpr | str, separator: SqlExpr | str | None = None
) -> SqlExpr:
    """Returns the head of the `path` (the pathname until the last slash) similarly to Python's `os.path.dirname`.

    `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.

    Args:
        path (SqlExpr | str): `VARCHAR` expression
        separator (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("parse_dirpath", path, separator)


def parse_duckdb_log_message(
    type_arg: SqlExpr | str, message: SqlExpr | str
) -> SqlExpr:
    """Parse the message into the expected logical type.

    Args:
        type_arg (SqlExpr | str): `VARCHAR` expression
        message (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("parse_duckdb_log_message", type_arg, message)


def parse_filename(
    string: SqlExpr | str,
    trim_extension: SqlExpr | bool | str | None = None,
    separator: SqlExpr | str | None = None,
) -> SqlExpr:
    """Returns the last component of the `path` similarly to Python's `os.path.basename` function.

    If `trim_extension` is `true`, the file extension will be removed (defaults to `false`).

    `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        trim_extension (SqlExpr | bool | str | None): `BOOLEAN | VARCHAR` expression
        separator (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("parse_filename", string, trim_extension, separator)


def parse_path(path: SqlExpr | str, separator: SqlExpr | str | None = None) -> SqlExpr:
    """Returns a list of the components (directories and filename) in the `path` similarly to Python's `pathlib.parts` function.

    `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.

    Args:
        path (SqlExpr | str): `VARCHAR` expression
        separator (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("parse_path", path, separator)


def pow(x: SqlExpr | float, y: SqlExpr | float) -> SqlExpr:
    """Computes x to the power of y.

    Args:
        x (SqlExpr | float): `DOUBLE` expression
        y (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("pow", x, y)


def power(x: SqlExpr | float, y: SqlExpr | float) -> SqlExpr:
    """Computes x to the power of y.

    Args:
        x (SqlExpr | float): `DOUBLE` expression
        y (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("power", x, y)


def prefix(string: SqlExpr | str, search_string: SqlExpr | str) -> SqlExpr:
    """Returns `true` if `string` starts with `search_string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        search_string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("prefix", string, search_string)


def printf(format_arg: SqlExpr | str, *args: SqlExpr) -> SqlExpr:
    """Formats a `string` using printf syntax.

    Args:
        format_arg (SqlExpr | str): `VARCHAR` expression
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("printf", format_arg, *args)


def quarter(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the quarter component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("quarter", ts)


def radians(x: SqlExpr | float) -> SqlExpr:
    """Converts degrees to radians.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("radians", x)


def range(
    start: SqlExpr | datetime | int,
    stop: SqlExpr | datetime | int | None = None,
    step: SqlExpr | int | timedelta | None = None,
) -> SqlExpr:
    """Creates a list of values between `start` and `stop` - the stop parameter is exclusive.

    Args:
        start (SqlExpr | datetime | int): `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
        stop (SqlExpr | datetime | int | None): `BIGINT | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
        step (SqlExpr | int | timedelta | None): `BIGINT | INTERVAL` expression

    Returns:
        SqlExpr
    """
    return func("range", start, stop, step)


def remap_struct(
    input_arg: SqlExpr, target_type: SqlExpr, mapping: SqlExpr, defaults: SqlExpr
) -> SqlExpr:
    """Map a struct to another struct type, potentially re-ordering, renaming and casting members and filling in defaults for missing values.

    Args:
        input_arg (SqlExpr): `ANY` expression
        target_type (SqlExpr): `ANY` expression
        mapping (SqlExpr): `ANY` expression
        defaults (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("remap_struct", input_arg, target_type, mapping, defaults)


def repeat(col0: SqlExpr, col1: SqlExpr | int) -> SqlExpr:
    """SQL repeat function.

    Args:
        col0 (SqlExpr): `T[]` expression
        col1 (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("repeat", col0, col1)


def replace(
    string: SqlExpr | str, source: SqlExpr | str, target: SqlExpr | str
) -> SqlExpr:
    """Replaces any occurrences of the `source` with `target` in `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        source (SqlExpr | str): `VARCHAR` expression
        target (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("replace", string, source, target)


def replace_type(param: SqlExpr, type1: SqlExpr, type2: SqlExpr) -> SqlExpr:
    """Casts all fields of type1 to type2.

    Args:
        param (SqlExpr): `ANY` expression
        type1 (SqlExpr): `ANY` expression
        type2 (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("replace_type", param, type1, type2)


def reverse(string: SqlExpr | str) -> SqlExpr:
    """Reverses the `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("reverse", string)


def right(string: SqlExpr | str, count: SqlExpr | int) -> SqlExpr:
    """Extract the right-most `count` characters.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        count (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("right", string, count)


def right_grapheme(string: SqlExpr | str, count: SqlExpr | int) -> SqlExpr:
    """Extracts the right-most `count` grapheme clusters.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        count (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("right_grapheme", string, count)


def round(
    x: SqlExpr | Decimal | float, precision: SqlExpr | int | None = None
) -> SqlExpr:
    """Rounds x to s decimal places.

    Args:
        x (SqlExpr | Decimal | float | int): `BIGINT | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | SMALLINT | TINYINT` expression
        precision (SqlExpr | int | None): `INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("round", x, precision)


def row(*args: SqlExpr) -> SqlExpr:
    """Create an unnamed STRUCT (tuple) containing the argument values.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("row", *args)


def row_to_json(*args: SqlExpr) -> SqlExpr:
    """SQL row_to_json function.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("row_to_json", *args)


def rpad(
    string: SqlExpr | str, count: SqlExpr | int, character: SqlExpr | str
) -> SqlExpr:
    """Pads the `string` with the `character` on the right until it has `count` characters.

    Truncates the `string` on the right if it has more than `count` characters.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        count (SqlExpr | int): `INTEGER` expression
        character (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("rpad", string, count, character)


def rtrim(string: SqlExpr | str, characters: SqlExpr | str | None = None) -> SqlExpr:
    """Removes any occurrences of any of the `characters` from the right side of the `string`.

    `characters` defaults to `space`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        characters (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("rtrim", string, characters)


def second(ts: SqlExpr | date | datetime | time | timedelta) -> SqlExpr:
    """Extract the second component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | time | timedelta): `DATE | INTERVAL | TIME | TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIME_NS` expression

    Returns:
        SqlExpr
    """
    return func("second", ts)


def set_bit(
    bitstring: SqlExpr | bytes | bytearray | memoryview,
    index: SqlExpr | int,
    new_value: SqlExpr | int,
) -> SqlExpr:
    """Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed 0.

    Returns a new bitstring.

    Args:
        bitstring (SqlExpr | bytes | bytearray | memoryview): `BIT` expression
        index (SqlExpr | int): `INTEGER` expression
        new_value (SqlExpr | int): `INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("set_bit", bitstring, index, new_value)


def setseed(col0: SqlExpr | float) -> SqlExpr:
    """Sets the seed to be used for the random function.

    Args:
        col0 (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("setseed", col0)


def sign(x: SqlExpr | float) -> SqlExpr:
    """Returns the sign of x as -1, 0 or 1.

    Args:
        x (SqlExpr | float | int): `BIGINT | DOUBLE | FLOAT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

    Returns:
        SqlExpr
    """
    return func("sign", x)


def signbit(x: SqlExpr | float) -> SqlExpr:
    """Returns whether the signbit is set or not.

    Args:
        x (SqlExpr | float): `DOUBLE | FLOAT` expression

    Returns:
        SqlExpr
    """
    return func("signbit", x)


def sin(x: SqlExpr | float) -> SqlExpr:
    """Computes the sin of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("sin", x)


def sinh(x: SqlExpr | float) -> SqlExpr:
    """Computes the hyperbolic sin of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("sinh", x)


def sqrt(x: SqlExpr | float) -> SqlExpr:
    """Returns the square root of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("sqrt", x)


def starts_with(string: SqlExpr | str, search_string: SqlExpr | str) -> SqlExpr:
    """Returns `true` if `string` begins with `search_string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        search_string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("starts_with", string, search_string)


def stats(expression: SqlExpr) -> SqlExpr:
    """Returns a string with statistics about the expression.

    Expression can be a column, constant, or SQL expression.

    Args:
        expression (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("stats", expression)


def strftime(
    data: SqlExpr | date | datetime | str, format_arg: SqlExpr | date | datetime | str
) -> SqlExpr:
    """Converts a `date` to a string according to the format string.

    Args:
        data (SqlExpr | date | datetime | str): `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE | TIMESTAMP_NS | VARCHAR` expression
        format_arg (SqlExpr | date | datetime | str): `DATE | TIMESTAMP | TIMESTAMP_NS | VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("strftime", data, format_arg)


def strip_accents(string: SqlExpr | str) -> SqlExpr:
    """Strips accents from `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("strip_accents", string)


def strlen(string: SqlExpr | str) -> SqlExpr:
    """Number of bytes in `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("strlen", string)


def strptime(text: SqlExpr | str, format_arg: SqlExpr | list[str] | str) -> SqlExpr:
    """Converts the `string` text to timestamp according to the format string.

    Throws an error on failure.

    To return `NULL` on failure, use try_strptime.

    Args:
        text (SqlExpr | str): `VARCHAR` expression
        format_arg (SqlExpr | list[str] | str): `VARCHAR | VARCHAR[]` expression

    Returns:
        SqlExpr
    """
    return func("strptime", text, format_arg)


def substring(
    string: SqlExpr | str, start: SqlExpr | int, length: SqlExpr | int | None = None
) -> SqlExpr:
    """Extracts substring starting from character `start` up to the end of the string.

    If optional argument `length` is set, extracts a substring of `length` characters instead.

    Note that a `start` value of `1` refers to the first character of the `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        start (SqlExpr | int): `BIGINT` expression
        length (SqlExpr | int | None): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("substring", string, start, length)


def substring_grapheme(
    string: SqlExpr | str, start: SqlExpr | int, length: SqlExpr | int | None = None
) -> SqlExpr:
    """Extracts substring starting from grapheme clusters `start` up to the end of the string.

    If optional argument `length` is set, extracts a substring of `length` grapheme clusters instead.

    Note that a `start` value of `1` refers to the `first` character of the `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        start (SqlExpr | int): `BIGINT` expression
        length (SqlExpr | int | None): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("substring_grapheme", string, start, length)


def subtract(
    col0: SqlExpr | Decimal | date | datetime | float | time | timedelta,
    col1: SqlExpr | Decimal | date | datetime | float | timedelta | None = None,
) -> SqlExpr:
    """SQL subtract function.

    Args:
        col0 (SqlExpr | Decimal | SqlExpr | date | datetime | float | int | time | timedelta): `BIGINT | BIGNUM | DATE | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | INTERVAL | SMALLINT | TIME | TIME WITH TIME ZONE | TIMESTAMP | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression
        col1 (SqlExpr | Decimal | SqlExpr | date | datetime | float | int | timedelta | None): `BIGINT | BIGNUM | DATE | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | INTERVAL | SMALLINT | TIMESTAMP | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

    Returns:
        SqlExpr
    """
    return func("subtract", col0, col1)


def suffix(string: SqlExpr | str, search_string: SqlExpr | str) -> SqlExpr:
    """Returns `true` if `string` ends with `search_string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        search_string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("suffix", string, search_string)


def tan(x: SqlExpr | float) -> SqlExpr:
    """Computes the tan of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("tan", x)


def tanh(x: SqlExpr | float) -> SqlExpr:
    """Computes the hyperbolic tan of x.

    Args:
        x (SqlExpr | float): `DOUBLE` expression

    Returns:
        SqlExpr
    """
    return func("tanh", x)


def translate(
    string: SqlExpr | str, from_arg: SqlExpr | str, to: SqlExpr | str
) -> SqlExpr:
    """Replaces each character in `string` that matches a character in the `from` set with the corresponding character in the `to` set.

    If `from` is longer than `to`, occurrences of the extra characters in `from` are deleted.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        from_arg (SqlExpr | str): `VARCHAR` expression
        to (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("translate", string, from_arg, to)


def trim(string: SqlExpr | str, characters: SqlExpr | str | None = None) -> SqlExpr:
    """Removes any occurrences of any of the `characters` from either side of the `string`.

    `characters` defaults to `space`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        characters (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("trim", string, characters)


def trunc(x: SqlExpr | Decimal | float, col1: SqlExpr | int | None = None) -> SqlExpr:
    """Truncates the number.

    Args:
        x (SqlExpr | Decimal | float | int): `BIGINT | DECIMAL | DOUBLE | FLOAT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression
        col1 (SqlExpr | int | None): `INTEGER` expression

    Returns:
        SqlExpr
    """
    return func("trunc", x, col1)


def try_strptime(text: SqlExpr | str, format_arg: SqlExpr | list[str] | str) -> SqlExpr:
    """Converts the `string` text to timestamp according to the format string.

    Returns `NULL` on failure.

    Args:
        text (SqlExpr | str): `VARCHAR` expression
        format_arg (SqlExpr | list[str] | str): `VARCHAR | VARCHAR[]` expression

    Returns:
        SqlExpr
    """
    return func("try_strptime", text, format_arg)


def typeof(expression: SqlExpr) -> SqlExpr:
    """Returns the name of the data type of the result of the expression.

    Args:
        expression (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("typeof", expression)


def unbin(value: SqlExpr | str) -> SqlExpr:
    """Converts a `value` from binary representation to a blob.

    Args:
        value (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("unbin", value)


def unhex(value: SqlExpr | str) -> SqlExpr:
    """Converts a `value` from hexadecimal representation to a blob.

    Args:
        value (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("unhex", value)


def unicode(string: SqlExpr | str) -> SqlExpr:
    """Returns an `INTEGER` representing the `unicode` codepoint of the first character in the `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("unicode", string)


def unpivot_list(*args: SqlExpr) -> SqlExpr:
    """Identical to list_value, but generated as part of unpivot for better error messages.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("unpivot_list", *args)


def upper(string: SqlExpr | str) -> SqlExpr:
    """Converts `string` to upper case.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("upper", string)


def url_decode(string: SqlExpr | str) -> SqlExpr:
    """Decodes a URL from a representation using Percent-Encoding.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("url_decode", string)


def url_encode(string: SqlExpr | str) -> SqlExpr:
    """Encodes a URL to a representation using Percent-Encoding.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("url_encode", string)


def uuid_extract_timestamp(uuid: SqlExpr | str) -> SqlExpr:
    """Extract the timestamp for the given UUID v7.

    Args:
        uuid (SqlExpr | str): `UUID` expression

    Returns:
        SqlExpr
    """
    return func("uuid_extract_timestamp", uuid)


def uuid_extract_version(uuid: SqlExpr | str) -> SqlExpr:
    """Extract a version for the given UUID.

    Args:
        uuid (SqlExpr | str): `UUID` expression

    Returns:
        SqlExpr
    """
    return func("uuid_extract_version", uuid)


def variant_extract(col0: SqlExpr, col1: SqlExpr | int | str) -> SqlExpr:
    """SQL variant_extract function.

    Args:
        col0 (SqlExpr): `VARIANT` expression
        col1 (SqlExpr | int | str): `UINTEGER | VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("variant_extract", col0, col1)


def variant_typeof(input_variant: SqlExpr) -> SqlExpr:
    """Returns the internal type of the `input_variant`.

    Args:
        input_variant (SqlExpr): `VARIANT` expression

    Returns:
        SqlExpr
    """
    return func("variant_typeof", input_variant)


def vector_type(col: SqlExpr) -> SqlExpr:
    """Returns the VectorType of a given column.

    Args:
        col (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("vector_type", col)


def week(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the week component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("week", ts)


def weekday(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the weekday component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("weekday", ts)


def weekofyear(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the weekofyear component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("weekofyear", ts)


def write_log(string: SqlExpr | str, *args: SqlExpr) -> SqlExpr:
    """Writes to the logger.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("write_log", string, *args)


def xor(
    left: SqlExpr | bytes | bytearray | memoryview | int,
    right: SqlExpr | bytes | bytearray | memoryview | int,
) -> SqlExpr:
    """Bitwise XOR.

    Args:
        left (SqlExpr | bytes | bytearray | memoryview | int): `BIGINT | BIT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression
        right (SqlExpr | bytes | bytearray | memoryview | int): `BIGINT | BIT | HUGEINT | INTEGER | SMALLINT | TINYINT | UBIGINT | UHUGEINT | UINTEGER | USMALLINT | UTINYINT` expression

    Returns:
        SqlExpr
    """
    return func("xor", left, right)


def year(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the year component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("year", ts)


def yearweek(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the yearweek component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("yearweek", ts)


# ============================================================
# Struct
# ============================================================


def struct_array_extract(
    struct: SqlExpr | dict[object, object], entry: SqlExpr | int | str
) -> SqlExpr:
    """Extracts the named `entry` from the `STRUCT`.

    Args:
        struct (SqlExpr | dict[object, object]): `STRUCT` expression
        entry (SqlExpr | int | str): `BIGINT | VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("array_extract", struct, entry)


def struct_concat(*args: SqlExpr) -> SqlExpr:
    """Merge the multiple STRUCTs into a single STRUCT.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("struct_concat", *args)


def struct_contains(struct: SqlExpr | dict[object, object], entry: SqlExpr) -> SqlExpr:
    """Check if an unnamed STRUCT contains the value.

    Args:
        struct (SqlExpr | dict[object, object]): `STRUCT` expression
        entry (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("struct_contains", struct, entry)


def struct_extract(
    struct: SqlExpr | dict[object, object], entry: SqlExpr | int | str
) -> SqlExpr:
    """Extract the named entry from the STRUCT.

    Args:
        struct (SqlExpr | dict[object, object]): `STRUCT` expression
        entry (SqlExpr | int | str): `BIGINT | VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("struct_extract", struct, entry)


def struct_extract_at(
    struct: SqlExpr | dict[object, object], entry: SqlExpr | int
) -> SqlExpr:
    """Extract the entry from the STRUCT by position (starts at 1!).

    Args:
        struct (SqlExpr | dict[object, object]): `STRUCT` expression
        entry (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("struct_extract_at", struct, entry)


def struct_insert(*args: SqlExpr) -> SqlExpr:
    """Adds field(s)/value(s) to an existing STRUCT with the argument values.

    The entry name(s) will be the bound variable name(s).

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("struct_insert", *args)


def struct_pack(*args: SqlExpr) -> SqlExpr:
    """Create a STRUCT containing the argument values.

    The entry name will be the bound variable name.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("struct_pack", *args)


def struct_position(struct: SqlExpr | dict[object, object], entry: SqlExpr) -> SqlExpr:
    """Get the position of the entry in an unnamed STRUCT, starting at 1.

    Args:
        struct (SqlExpr | dict[object, object]): `STRUCT` expression
        entry (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("struct_position", struct, entry)


def struct_update(*args: SqlExpr) -> SqlExpr:
    """Changes field(s)/value(s) to an existing STRUCT with the argument values.

    The entry name(s) will be the bound variable name(s).

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("struct_update", *args)


# ============================================================
# Text
# ============================================================


def string_agg(str_arg: SqlExpr, arg: SqlExpr | str | None = None) -> SqlExpr:
    """Concatenates the column string values with an optional separator.

    Args:
        str_arg (SqlExpr): `ANY` expression
        arg (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("string_agg", str_arg, arg)


def string_array_extract(string: SqlExpr | str, index: SqlExpr | int) -> SqlExpr:
    """Extracts a single character from a `string` using a (1-based) `index`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        index (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("array_extract", string, index)


def string_bin(string: SqlExpr | str) -> SqlExpr:
    """Converts the `string` to binary representation.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("bin", string)


def string_bit_length(string: SqlExpr | str) -> SqlExpr:
    """Number of bits in a `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("bit_length", string)


def string_contains(string: SqlExpr | str, search_string: SqlExpr | str) -> SqlExpr:
    """Returns `true` if `search_string` is found within `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        search_string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("contains", string, search_string)


def string_hex(string: SqlExpr | str) -> SqlExpr:
    """Converts the `string` to hexadecimal representation.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("hex", string)


def string_length(string: SqlExpr | str) -> SqlExpr:
    """Number of characters in `string`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("length", string)


def string_md5(string: SqlExpr | str) -> SqlExpr:
    """Returns the MD5 hash of the `string` as a `VARCHAR`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("md5", string)


def string_md5_number(string: SqlExpr | str) -> SqlExpr:
    """Returns the MD5 hash of the `string` as a `HUGEINT`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("md5_number", string)


def string_repeat(string: SqlExpr | str, count: SqlExpr | int) -> SqlExpr:
    """Repeats the `string` `count` number of times.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        count (SqlExpr | int): `BIGINT` expression

    Returns:
        SqlExpr
    """
    return func("repeat", string, count)


def string_sha1(value: SqlExpr | str) -> SqlExpr:
    """Returns a `VARCHAR` with the SHA-1 hash of the `value`.

    Args:
        value (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("sha1", value)


def string_sha256(value: SqlExpr | str) -> SqlExpr:
    """Returns a `VARCHAR` with the SHA-256 hash of the `value`.

    Args:
        value (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("sha256", value)


def string_split(string: SqlExpr | str, separator: SqlExpr | str) -> SqlExpr:
    """Splits the `string` along the `separator`.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        separator (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("string_split", string, separator)


def string_split_regex(
    string: SqlExpr | str, regex: SqlExpr | str, options: SqlExpr | str | None = None
) -> SqlExpr:
    """Splits the `string` along the `regex`.

    A set of optional regex `options` can be set.

    Args:
        string (SqlExpr | str): `VARCHAR` expression
        regex (SqlExpr | str): `VARCHAR` expression
        options (SqlExpr | str | None): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("string_split_regex", string, regex, options)


# ============================================================
# Time
# ============================================================


def time_bucket(
    bucket_width: SqlExpr | timedelta,
    timestamp: SqlExpr | date | datetime,
    origin: SqlExpr | date | datetime | str | timedelta | None = None,
) -> SqlExpr:
    """Truncate TIMESTAMPTZ by the specified interval bucket_width.

    Buckets are aligned relative to origin TIMESTAMPTZ.

    The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets.

    Args:
        bucket_width (SqlExpr | timedelta): `INTERVAL` expression
        timestamp (SqlExpr | date | datetime): `DATE | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression
        origin (SqlExpr | date | datetime | str | timedelta | None): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("time_bucket", bucket_width, timestamp, origin)


def timetz_byte_comparable(time_tz: SqlExpr | time) -> SqlExpr:
    """Converts a TIME WITH TIME ZONE to an integer sort key.

    Args:
        time_tz (SqlExpr | time): `TIME WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("timetz_byte_comparable", time_tz)


def timezone(
    ts: SqlExpr | date | datetime | str | timedelta,
    col1: SqlExpr | datetime | time | None = None,
) -> SqlExpr:
    """Extract the timezone component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | str | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE | VARCHAR` expression
        col1 (SqlExpr | datetime | time | None): `TIME WITH TIME ZONE | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("timezone", ts, col1)


def timezone_hour(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the timezone_hour component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("timezone_hour", ts)


def timezone_minute(ts: SqlExpr | date | datetime | timedelta) -> SqlExpr:
    """Extract the timezone_minute component from a date or timestamp.

    Args:
        ts (SqlExpr | date | datetime | timedelta): `DATE | INTERVAL | TIMESTAMP | TIMESTAMP WITH TIME ZONE` expression

    Returns:
        SqlExpr
    """
    return func("timezone_minute", ts)


# ============================================================
# Union
# ============================================================


def union_extract(union: SqlExpr, tag: SqlExpr | str) -> SqlExpr:
    """Extract the value with the named tags from the union.

    NULL if the tag is not currently selected.

    Args:
        union (SqlExpr): `UNION` expression
        tag (SqlExpr | str): `VARCHAR` expression

    Returns:
        SqlExpr
    """
    return func("union_extract", union, tag)


def union_tag(union: SqlExpr) -> SqlExpr:
    """Retrieve the currently selected tag of the union as an ENUM.

    Args:
        union (SqlExpr): `UNION` expression

    Returns:
        SqlExpr
    """
    return func("union_tag", union)


def union_value(*args: SqlExpr) -> SqlExpr:
    """Create a single member UNION containing the argument value.

    The tag of the value will be the bound variable name.

    Args:
        *args (SqlExpr): `ANY` expression

    Returns:
        SqlExpr
    """
    return func("union_value", *args)


# ============================================================
# Window Functions
# ============================================================


def cume_dist() -> SqlExpr:
    """The cumulative distribution: (number of partition rows preceding or peer with current row) / total partition rows.

    If an ORDER BY clause is specified, the distribution is computed within the frame using the provided ordering instead of the frame ordering.

    Returns:
        SqlExpr
    """
    return func("cume_dist")


def dense_rank() -> SqlExpr:
    """The rank of the current row without gaps; this function counts peer groups.

    Returns:
        SqlExpr
    """
    return func("dense_rank")


def fill(expr: SqlExpr) -> SqlExpr:
    """Replaces NULL values of expr with a linear interpolation based on the closest non-NULL values and the sort values.

    Both values must support arithmetic and there must be only one ordering key. For missing values at the ends, linear extrapolation is used. Failure to interpolate results in the NULL value being retained.

    Args:
        expr (SqlExpr): Expression to fill

    Returns:
        SqlExpr
    """
    return func("fill", expr)


def first_value(expr: SqlExpr) -> SqlExpr:
    """Returns expr evaluated at the row that is the first row (with a non-null value of expr if IGNORE NULLS is set) of the window frame.

    If an ORDER BY clause is specified, the first row number is computed within the frame using the provided ordering instead of the frame ordering.

    Args:
        expr (SqlExpr): Expression to evaluate

    Returns:
        SqlExpr
    """
    return func("first_value", expr)


def lag(
    expr: SqlExpr, offset: SqlExpr | int = 1, default: SqlExpr | None = None
) -> SqlExpr:
    """Returns expr evaluated at the row that is offset rows (among rows with a non-null value of expr if IGNORE NULLS is set) before the current row within the window frame; if there is no such row, instead return default (which must be of the Same type as expr).

    Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to NULL. If an ORDER BY clause is specified, the lagged row number is computed within the frame using the provided ordering instead of the frame ordering.

    Args:
        expr (SqlExpr): Expression to evaluate
        offset (SqlExpr | int): Number of rows to look back (default: 1)
        default (SqlExpr | None): Default value if no such row exists (default: NULL)

    Returns:
        SqlExpr
    """
    return func("lag", expr, offset, default)


def last_value(expr: SqlExpr) -> SqlExpr:
    """Returns expr evaluated at the row that is the last row (among rows with a non-null value of expr if IGNORE NULLS is set) of the window frame.

    If an ORDER BY clause is specified, the last row is determined within the frame using the provided ordering instead of the frame ordering.

    Args:
        expr (SqlExpr): Expression to evaluate

    Returns:
        SqlExpr
    """
    return func("last_value", expr)


def lead(
    expr: SqlExpr, offset: SqlExpr | int = 1, default: SqlExpr | None = None
) -> SqlExpr:
    """Returns expr evaluated at the row that is offset rows after the current row (among rows with a non-null value of expr if IGNORE NULLS is set) within the window frame; if there is no such row, instead return default (which must be of the Same type as expr).

    Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to NULL. If an ORDER BY clause is specified, the leading row number is computed within the frame using the provided ordering instead of the frame ordering.

    Args:
        expr (SqlExpr): Expression to evaluate
        offset (SqlExpr | int): Number of rows to look ahead (default: 1)
        default (SqlExpr | None): Default value if no such row exists (default: NULL)

    Returns:
        SqlExpr
    """
    return func("lead", expr, offset, default)


def nth_value(expr: SqlExpr, nth: SqlExpr | int) -> SqlExpr:
    """Returns expr evaluated at the nth row (among rows with a non-null value of expr if IGNORE NULLS is set) of the window frame (counting from 1); NULL if no such row.

    If an ORDER BY clause is specified, the nth row number is computed within the frame using the provided ordering instead of the frame ordering.

    Args:
        expr (SqlExpr): Expression to evaluate
        nth (SqlExpr | int): The row number to retrieve (1-based)

    Returns:
        SqlExpr
    """
    return func("nth_value", expr, nth)


def ntile(num_buckets: SqlExpr | int) -> SqlExpr:
    """An integer ranging from 1 to num_buckets, dividing the partition as equally as possible.

    If an ORDER BY clause is specified, the ntile is computed within the frame using the provided ordering instead of the frame ordering.

    Args:
        num_buckets (SqlExpr | int): Number of buckets to divide into

    Returns:
        SqlExpr
    """
    return func("ntile", num_buckets)


def percent_rank() -> SqlExpr:
    """The relative rank of the current row: (rank() - 1) / (total partition rows - 1).

    If an ORDER BY clause is specified, the relative rank is computed within the frame using the provided ordering instead of the frame ordering.

    Returns:
        SqlExpr
    """
    return func("percent_rank")


def rank() -> SqlExpr:
    """The rank of the current row with gaps; same as row_number of its first peer.

    If an ORDER BY clause is specified, the rank is computed within the frame using the provided ordering instead of the frame ordering.

    Returns:
        SqlExpr
    """
    return func("rank")


def row_number() -> SqlExpr:
    """The number of the current row within the partition, counting from 1.

    If an ORDER BY clause is specified, the row number is computed within the frame using the provided ordering instead of the frame ordering.

    Returns:
        SqlExpr
    """
    return func("row_number")
