from __future__ import annotations

from dataclasses import dataclass
from textwrap import dedent
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import pyochain as pc


@dataclass(slots=True)
class FunctionInfo:
    """Container for pre-formatted function parts."""

    category: str
    python_name: str
    signature: str
    docstring: str
    body: str

    def generate_function(self) -> str:
        """Assemble complete function definition."""
        return f"{self.signature}\n{self.docstring}\n{self.body}"


def build_file(fns: pc.Seq[FunctionInfo]) -> str:
    all_names = fns.iter().map(lambda f: f'    "{f.python_name}",').join("\n")
    sections = (
        fns.iter()
        .group_by(lambda f: f.category)
        .map_star(
            lambda category, funcs: f"\n\n# {'=' * 60}\n# {category}\n# {'=' * 60}\n\n"
            + funcs.map(lambda f: f.generate_function()).join("\n\n\n")
        )
        .join("")
    )
    return f"{_header()}{all_names}\n]{sections}\n"


def _header() -> str:
    return dedent('''\
        """DuckDB SQL function wrappers with type hints.

        This file is AUTO-GENERATED by scripts/generate_fns.py
        Do not edit manually - regenerate with:
            uv run scripts/generate_fns.py

        Functions are extracted from DuckDB's duckdb_functions() introspection.
        """

        from __future__ import annotations

        from datetime import date, datetime, time, timedelta

        from ._exprs import SqlExpr, func

        __all__ = [
    ''')
