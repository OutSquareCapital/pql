from __future__ import annotations

import ast
from dataclasses import dataclass
from pathlib import Path
from textwrap import dedent
from typing import TypeIs

import pyochain as pc

MANUAL_FNS_PATH = Path("src", "pql", "sql", "_manual_fns.py")


@dataclass(slots=True)
class FunctionInfo:
    """Container for pre-formatted function parts."""

    category: str
    python_name: str
    func: str


def build_file(fns: pc.Iter[FunctionInfo]) -> str:

    all_fns = fns.chain(_parse_manual_functions()).collect()

    all_names = all_fns.iter().map(lambda f: f'    "{f.python_name}",').join("\n")
    sections = (
        all_fns.iter()
        .group_by(lambda f: f.category)
        .map_star(
            lambda category, funcs: (
                f"\n\n# {'=' * 60}\n# {category}\n# {'=' * 60}\n\n"
                + funcs.map(lambda f: f.func).join("\n\n\n")
            )
        )
        .join("")
    )
    return f"{_header()}{all_names}\n]{sections}\n"


def _header() -> str:
    return dedent('''\
        """DuckDB SQL function wrappers with type hints.

        This file is AUTO-GENERATED by scripts/generate_fns.py
        Do not edit manually - regenerate with:
            uv run -m scripts/generate_fns.py

        Functions are extracted from DuckDB's duckdb_functions() introspection.
        """

        from __future__ import annotations

        from datetime import date, datetime, time, timedelta
        from decimal import Decimal

        from ._exprs import SqlExpr, func

        __all__ = [
    ''')


def _parse_manual_functions() -> pc.Iter[FunctionInfo]:

    content = MANUAL_FNS_PATH.read_text(encoding="utf-8")

    def _is_function_def(node: ast.stmt) -> TypeIs[ast.FunctionDef]:
        return isinstance(node, ast.FunctionDef)

    def _extract_function(node: ast.FunctionDef) -> FunctionInfo:
        return FunctionInfo(
            category="Window Functions",
            python_name=node.name,
            func=pc.Option(ast.get_source_segment(content, node)).unwrap_or(""),
        )

    return (
        pc.Iter(ast.parse(content).body).filter(_is_function_def).map(_extract_function)
    )
