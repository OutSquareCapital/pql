from __future__ import annotations

from dataclasses import dataclass

import pyochain as pc

from ._rules import NAMESPACE_SPECS, NamespaceSpec


@dataclass(slots=True)
class FunctionInfo:
    """Container for pre-formatted function parts."""

    namespace: str | None
    python_name: str
    func: str


def build_file(fns: pc.Seq[FunctionInfo]) -> str:
    def _body(funcs: pc.Seq[FunctionInfo]) -> str:
        return funcs.then(
            lambda x: x.iter().map(lambda f: f.func).join("\n\n")
        ).unwrap_or("    pass")

    def _class_block(
        name: str,
        doc: str,
        funcs: pc.Seq[FunctionInfo],
        base: str,
        type_params: str | None = None,
    ) -> str:
        params = pc.Option(type_params).map(lambda tp: f"[{tp}]").unwrap_or("")
        return (
            f'\n\nclass {name}{params}({base}):\n    """{doc}"""\n{funcs.into(_body)}'
        )

    def _namespace_block(spec: NamespaceSpec) -> str:
        return _class_block(
            spec.name,
            spec.doc,
            fns.iter().filter(lambda f: f.namespace == spec.name).collect(),
            "NameSpaceHandler[T]",
            "T: Fns",
        )

    base_fns = fns.iter().filter(lambda f: f.namespace is None).collect()

    return (
        f"{_header()}"
        f"{_class_block('Fns', 'Mixin providing auto-generated DuckDB functions as methods.', base_fns, 'DuckHandler')}"
        f"{NAMESPACE_SPECS.iter().map(_namespace_block).join('')}\n"
    )


def _header() -> str:
    return '''
"""DuckDB SQL function wrappers with type hints.

This file is AUTO-GENERATED by scripts/generate_fns.py
Do not edit manually - regenerate with:
    uv run -m scripts.generator

Functions are extracted from DuckDB's duckdb_functions() introspection.
"""

from __future__ import annotations

from datetime import date, datetime, time, timedelta
from typing import Self

from .._core import DuckHandler, NameSpaceHandler, func
'''
